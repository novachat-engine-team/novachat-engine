// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: schema.tl.transport.proto

package mtproto

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

///////////////////////////////////////////////////////////////////////////////
// AccessPointRule <--
//  + TL_accessPointRule
//
type AccessPointRule struct {
	Cmd                  TLCmd     `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string    `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	PhonePrefixRules     string    `protobuf:"bytes,3,opt,name=phone_prefix_rules,json=phonePrefixRules,proto3" json:"phone_prefix_rules,omitempty"`
	DcId                 int32     `protobuf:"varint,4,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	Ips                  []*IpPort `protobuf:"bytes,5,rep,name=ips,proto3" json:"ips,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AccessPointRule) Reset()         { *m = AccessPointRule{} }
func (m *AccessPointRule) String() string { return proto.CompactTextString(m) }
func (*AccessPointRule) ProtoMessage()    {}
func (*AccessPointRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{0}
}
func (m *AccessPointRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessPointRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessPointRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessPointRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessPointRule.Merge(m, src)
}
func (m *AccessPointRule) XXX_Size() int {
	return m.Size()
}
func (m *AccessPointRule) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessPointRule.DiscardUnknown(m)
}

var xxx_messageInfo_AccessPointRule proto.InternalMessageInfo

func (m *AccessPointRule) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *AccessPointRule) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *AccessPointRule) GetPhonePrefixRules() string {
	if m != nil {
		return m.PhonePrefixRules
	}
	return ""
}

func (m *AccessPointRule) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

func (m *AccessPointRule) GetIps() []*IpPort {
	if m != nil {
		return m.Ips
	}
	return nil
}

//  accessPointRule#4679b65f phone_prefix_rules:string dc_id:int ips:vector<IpPort> = AccessPointRule;
//
type TLAccessPointRule struct {
	Data2                *AccessPointRule `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TLAccessPointRule) Reset()         { *m = TLAccessPointRule{} }
func (m *TLAccessPointRule) String() string { return proto.CompactTextString(m) }
func (*TLAccessPointRule) ProtoMessage()    {}
func (*TLAccessPointRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{1}
}
func (m *TLAccessPointRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAccessPointRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAccessPointRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAccessPointRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAccessPointRule.Merge(m, src)
}
func (m *TLAccessPointRule) XXX_Size() int {
	return m.Size()
}
func (m *TLAccessPointRule) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAccessPointRule.DiscardUnknown(m)
}

var xxx_messageInfo_TLAccessPointRule proto.InternalMessageInfo

func (m *TLAccessPointRule) GetData2() *AccessPointRule {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// BadMsgNotification <--
//  + TL_bad_msg_notification
//  + TL_bad_server_salt
//
type BadMsgNotification struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	BadMsgId             int64    `protobuf:"varint,3,opt,name=bad_msg_id,json=badMsgId,proto3" json:"bad_msg_id,omitempty"`
	BadMsgSeqno          int32    `protobuf:"varint,4,opt,name=bad_msg_seqno,json=badMsgSeqno,proto3" json:"bad_msg_seqno,omitempty"`
	ErrorCode            int32    `protobuf:"varint,5,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	NewServerSalt        int64    `protobuf:"varint,6,opt,name=new_server_salt,json=newServerSalt,proto3" json:"new_server_salt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BadMsgNotification) Reset()         { *m = BadMsgNotification{} }
func (m *BadMsgNotification) String() string { return proto.CompactTextString(m) }
func (*BadMsgNotification) ProtoMessage()    {}
func (*BadMsgNotification) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{2}
}
func (m *BadMsgNotification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BadMsgNotification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BadMsgNotification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BadMsgNotification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BadMsgNotification.Merge(m, src)
}
func (m *BadMsgNotification) XXX_Size() int {
	return m.Size()
}
func (m *BadMsgNotification) XXX_DiscardUnknown() {
	xxx_messageInfo_BadMsgNotification.DiscardUnknown(m)
}

var xxx_messageInfo_BadMsgNotification proto.InternalMessageInfo

func (m *BadMsgNotification) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *BadMsgNotification) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *BadMsgNotification) GetBadMsgId() int64 {
	if m != nil {
		return m.BadMsgId
	}
	return 0
}

func (m *BadMsgNotification) GetBadMsgSeqno() int32 {
	if m != nil {
		return m.BadMsgSeqno
	}
	return 0
}

func (m *BadMsgNotification) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *BadMsgNotification) GetNewServerSalt() int64 {
	if m != nil {
		return m.NewServerSalt
	}
	return 0
}

//  bad_msg_notification#a7eff811 bad_msg_id:long bad_msg_seqno:int error_code:int = BadMsgNotification;
//
type TLBadMsgNotification struct {
	Data2                *BadMsgNotification `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TLBadMsgNotification) Reset()         { *m = TLBadMsgNotification{} }
func (m *TLBadMsgNotification) String() string { return proto.CompactTextString(m) }
func (*TLBadMsgNotification) ProtoMessage()    {}
func (*TLBadMsgNotification) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{3}
}
func (m *TLBadMsgNotification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLBadMsgNotification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLBadMsgNotification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLBadMsgNotification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLBadMsgNotification.Merge(m, src)
}
func (m *TLBadMsgNotification) XXX_Size() int {
	return m.Size()
}
func (m *TLBadMsgNotification) XXX_DiscardUnknown() {
	xxx_messageInfo_TLBadMsgNotification.DiscardUnknown(m)
}

var xxx_messageInfo_TLBadMsgNotification proto.InternalMessageInfo

func (m *TLBadMsgNotification) GetData2() *BadMsgNotification {
	if m != nil {
		return m.Data2
	}
	return nil
}

//  bad_server_salt#edab447b bad_msg_id:long bad_msg_seqno:int error_code:int new_server_salt:long = BadMsgNotification;
//
type TLBadServerSalt struct {
	Data2                *BadMsgNotification `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TLBadServerSalt) Reset()         { *m = TLBadServerSalt{} }
func (m *TLBadServerSalt) String() string { return proto.CompactTextString(m) }
func (*TLBadServerSalt) ProtoMessage()    {}
func (*TLBadServerSalt) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{4}
}
func (m *TLBadServerSalt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLBadServerSalt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLBadServerSalt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLBadServerSalt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLBadServerSalt.Merge(m, src)
}
func (m *TLBadServerSalt) XXX_Size() int {
	return m.Size()
}
func (m *TLBadServerSalt) XXX_DiscardUnknown() {
	xxx_messageInfo_TLBadServerSalt.DiscardUnknown(m)
}

var xxx_messageInfo_TLBadServerSalt proto.InternalMessageInfo

func (m *TLBadServerSalt) GetData2() *BadMsgNotification {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// DestroySessionRes <--
//  + TL_destroy_session_ok
//  + TL_destroy_session_none
//
type DestroySessionRes struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	SessionId            int64    `protobuf:"varint,3,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DestroySessionRes) Reset()         { *m = DestroySessionRes{} }
func (m *DestroySessionRes) String() string { return proto.CompactTextString(m) }
func (*DestroySessionRes) ProtoMessage()    {}
func (*DestroySessionRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{5}
}
func (m *DestroySessionRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DestroySessionRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DestroySessionRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DestroySessionRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DestroySessionRes.Merge(m, src)
}
func (m *DestroySessionRes) XXX_Size() int {
	return m.Size()
}
func (m *DestroySessionRes) XXX_DiscardUnknown() {
	xxx_messageInfo_DestroySessionRes.DiscardUnknown(m)
}

var xxx_messageInfo_DestroySessionRes proto.InternalMessageInfo

func (m *DestroySessionRes) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *DestroySessionRes) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *DestroySessionRes) GetSessionId() int64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

//  destroy_session_ok#e22045fc session_id:long = DestroySessionRes;
//
type TLDestroySessionOk struct {
	Data2                *DestroySessionRes `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLDestroySessionOk) Reset()         { *m = TLDestroySessionOk{} }
func (m *TLDestroySessionOk) String() string { return proto.CompactTextString(m) }
func (*TLDestroySessionOk) ProtoMessage()    {}
func (*TLDestroySessionOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{6}
}
func (m *TLDestroySessionOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDestroySessionOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDestroySessionOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDestroySessionOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDestroySessionOk.Merge(m, src)
}
func (m *TLDestroySessionOk) XXX_Size() int {
	return m.Size()
}
func (m *TLDestroySessionOk) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDestroySessionOk.DiscardUnknown(m)
}

var xxx_messageInfo_TLDestroySessionOk proto.InternalMessageInfo

func (m *TLDestroySessionOk) GetData2() *DestroySessionRes {
	if m != nil {
		return m.Data2
	}
	return nil
}

//  destroy_session_none#62d350c9 session_id:long = DestroySessionRes;
//
type TLDestroySessionNone struct {
	Data2                *DestroySessionRes `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLDestroySessionNone) Reset()         { *m = TLDestroySessionNone{} }
func (m *TLDestroySessionNone) String() string { return proto.CompactTextString(m) }
func (*TLDestroySessionNone) ProtoMessage()    {}
func (*TLDestroySessionNone) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{7}
}
func (m *TLDestroySessionNone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDestroySessionNone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDestroySessionNone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDestroySessionNone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDestroySessionNone.Merge(m, src)
}
func (m *TLDestroySessionNone) XXX_Size() int {
	return m.Size()
}
func (m *TLDestroySessionNone) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDestroySessionNone.DiscardUnknown(m)
}

var xxx_messageInfo_TLDestroySessionNone proto.InternalMessageInfo

func (m *TLDestroySessionNone) GetData2() *DestroySessionRes {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// FutureSalt <--
//  + TL_future_salt
//
type FutureSalt struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	ValidSince           int32    `protobuf:"varint,3,opt,name=valid_since,json=validSince,proto3" json:"valid_since,omitempty"`
	ValidUntil           int32    `protobuf:"varint,4,opt,name=valid_until,json=validUntil,proto3" json:"valid_until,omitempty"`
	Salt                 int64    `protobuf:"varint,5,opt,name=salt,proto3" json:"salt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FutureSalt) Reset()         { *m = FutureSalt{} }
func (m *FutureSalt) String() string { return proto.CompactTextString(m) }
func (*FutureSalt) ProtoMessage()    {}
func (*FutureSalt) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{8}
}
func (m *FutureSalt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FutureSalt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FutureSalt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FutureSalt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FutureSalt.Merge(m, src)
}
func (m *FutureSalt) XXX_Size() int {
	return m.Size()
}
func (m *FutureSalt) XXX_DiscardUnknown() {
	xxx_messageInfo_FutureSalt.DiscardUnknown(m)
}

var xxx_messageInfo_FutureSalt proto.InternalMessageInfo

func (m *FutureSalt) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *FutureSalt) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *FutureSalt) GetValidSince() int32 {
	if m != nil {
		return m.ValidSince
	}
	return 0
}

func (m *FutureSalt) GetValidUntil() int32 {
	if m != nil {
		return m.ValidUntil
	}
	return 0
}

func (m *FutureSalt) GetSalt() int64 {
	if m != nil {
		return m.Salt
	}
	return 0
}

//  future_salt#0949d9dc valid_since:int valid_until:int salt:long = FutureSalt;
//
type TLFutureSalt struct {
	Data2                *FutureSalt `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TLFutureSalt) Reset()         { *m = TLFutureSalt{} }
func (m *TLFutureSalt) String() string { return proto.CompactTextString(m) }
func (*TLFutureSalt) ProtoMessage()    {}
func (*TLFutureSalt) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{9}
}
func (m *TLFutureSalt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLFutureSalt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLFutureSalt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLFutureSalt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLFutureSalt.Merge(m, src)
}
func (m *TLFutureSalt) XXX_Size() int {
	return m.Size()
}
func (m *TLFutureSalt) XXX_DiscardUnknown() {
	xxx_messageInfo_TLFutureSalt.DiscardUnknown(m)
}

var xxx_messageInfo_TLFutureSalt proto.InternalMessageInfo

func (m *TLFutureSalt) GetData2() *FutureSalt {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// FutureSalts <--
//  + TL_future_salts
//
type FutureSalts struct {
	Cmd                  TLCmd           `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string          `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	ReqMsgId             int64           `protobuf:"varint,3,opt,name=req_msg_id,json=reqMsgId,proto3" json:"req_msg_id,omitempty"`
	Now                  int32           `protobuf:"varint,4,opt,name=now,proto3" json:"now,omitempty"`
	Salts                []*TLFutureSalt `protobuf:"bytes,5,rep,name=salts,proto3" json:"salts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *FutureSalts) Reset()         { *m = FutureSalts{} }
func (m *FutureSalts) String() string { return proto.CompactTextString(m) }
func (*FutureSalts) ProtoMessage()    {}
func (*FutureSalts) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{10}
}
func (m *FutureSalts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FutureSalts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FutureSalts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FutureSalts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FutureSalts.Merge(m, src)
}
func (m *FutureSalts) XXX_Size() int {
	return m.Size()
}
func (m *FutureSalts) XXX_DiscardUnknown() {
	xxx_messageInfo_FutureSalts.DiscardUnknown(m)
}

var xxx_messageInfo_FutureSalts proto.InternalMessageInfo

func (m *FutureSalts) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *FutureSalts) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *FutureSalts) GetReqMsgId() int64 {
	if m != nil {
		return m.ReqMsgId
	}
	return 0
}

func (m *FutureSalts) GetNow() int32 {
	if m != nil {
		return m.Now
	}
	return 0
}

func (m *FutureSalts) GetSalts() []*TLFutureSalt {
	if m != nil {
		return m.Salts
	}
	return nil
}

//  future_salts#ae500895 req_msg_id:long now:int salts:vector<future_salt> = FutureSalts;
//
type TLFutureSalts struct {
	Data2                *FutureSalts `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TLFutureSalts) Reset()         { *m = TLFutureSalts{} }
func (m *TLFutureSalts) String() string { return proto.CompactTextString(m) }
func (*TLFutureSalts) ProtoMessage()    {}
func (*TLFutureSalts) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{11}
}
func (m *TLFutureSalts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLFutureSalts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLFutureSalts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLFutureSalts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLFutureSalts.Merge(m, src)
}
func (m *TLFutureSalts) XXX_Size() int {
	return m.Size()
}
func (m *TLFutureSalts) XXX_DiscardUnknown() {
	xxx_messageInfo_TLFutureSalts.DiscardUnknown(m)
}

var xxx_messageInfo_TLFutureSalts proto.InternalMessageInfo

func (m *TLFutureSalts) GetData2() *FutureSalts {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// HttpWait <--
//  + TL_http_wait
//
type HttpWait struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	MaxDelay             int32    `protobuf:"varint,3,opt,name=max_delay,json=maxDelay,proto3" json:"max_delay,omitempty"`
	WaitAfter            int32    `protobuf:"varint,4,opt,name=wait_after,json=waitAfter,proto3" json:"wait_after,omitempty"`
	MaxWait              int32    `protobuf:"varint,5,opt,name=max_wait,json=maxWait,proto3" json:"max_wait,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HttpWait) Reset()         { *m = HttpWait{} }
func (m *HttpWait) String() string { return proto.CompactTextString(m) }
func (*HttpWait) ProtoMessage()    {}
func (*HttpWait) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{12}
}
func (m *HttpWait) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpWait) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpWait.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpWait) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpWait.Merge(m, src)
}
func (m *HttpWait) XXX_Size() int {
	return m.Size()
}
func (m *HttpWait) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpWait.DiscardUnknown(m)
}

var xxx_messageInfo_HttpWait proto.InternalMessageInfo

func (m *HttpWait) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *HttpWait) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *HttpWait) GetMaxDelay() int32 {
	if m != nil {
		return m.MaxDelay
	}
	return 0
}

func (m *HttpWait) GetWaitAfter() int32 {
	if m != nil {
		return m.WaitAfter
	}
	return 0
}

func (m *HttpWait) GetMaxWait() int32 {
	if m != nil {
		return m.MaxWait
	}
	return 0
}

//  http_wait#9299359f max_delay:int wait_after:int max_wait:int = HttpWait;
//
type TLHttpWait struct {
	Data2                *HttpWait `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TLHttpWait) Reset()         { *m = TLHttpWait{} }
func (m *TLHttpWait) String() string { return proto.CompactTextString(m) }
func (*TLHttpWait) ProtoMessage()    {}
func (*TLHttpWait) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{13}
}
func (m *TLHttpWait) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLHttpWait) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLHttpWait.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLHttpWait) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLHttpWait.Merge(m, src)
}
func (m *TLHttpWait) XXX_Size() int {
	return m.Size()
}
func (m *TLHttpWait) XXX_DiscardUnknown() {
	xxx_messageInfo_TLHttpWait.DiscardUnknown(m)
}

var xxx_messageInfo_TLHttpWait proto.InternalMessageInfo

func (m *TLHttpWait) GetData2() *HttpWait {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// IpPort <--
//  + TL_ipPort
//  + TL_ipPortSecret
//
type IpPort struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	Ipv4                 int32    `protobuf:"varint,3,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	Port                 int32    `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
	Secret               []byte   `protobuf:"bytes,5,opt,name=secret,proto3" json:"secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IpPort) Reset()         { *m = IpPort{} }
func (m *IpPort) String() string { return proto.CompactTextString(m) }
func (*IpPort) ProtoMessage()    {}
func (*IpPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{14}
}
func (m *IpPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpPort.Merge(m, src)
}
func (m *IpPort) XXX_Size() int {
	return m.Size()
}
func (m *IpPort) XXX_DiscardUnknown() {
	xxx_messageInfo_IpPort.DiscardUnknown(m)
}

var xxx_messageInfo_IpPort proto.InternalMessageInfo

func (m *IpPort) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *IpPort) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *IpPort) GetIpv4() int32 {
	if m != nil {
		return m.Ipv4
	}
	return 0
}

func (m *IpPort) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *IpPort) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

//  ipPort#d433ad73 ipv4:int port:int = IpPort;
//
type TLIpPort struct {
	Data2                *IpPort  `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLIpPort) Reset()         { *m = TLIpPort{} }
func (m *TLIpPort) String() string { return proto.CompactTextString(m) }
func (*TLIpPort) ProtoMessage()    {}
func (*TLIpPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{15}
}
func (m *TLIpPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLIpPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLIpPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLIpPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLIpPort.Merge(m, src)
}
func (m *TLIpPort) XXX_Size() int {
	return m.Size()
}
func (m *TLIpPort) XXX_DiscardUnknown() {
	xxx_messageInfo_TLIpPort.DiscardUnknown(m)
}

var xxx_messageInfo_TLIpPort proto.InternalMessageInfo

func (m *TLIpPort) GetData2() *IpPort {
	if m != nil {
		return m.Data2
	}
	return nil
}

//  ipPortSecret#37982646 ipv4:int port:int secret:bytes = IpPort;
//
type TLIpPortSecret struct {
	Data2                *IpPort  `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLIpPortSecret) Reset()         { *m = TLIpPortSecret{} }
func (m *TLIpPortSecret) String() string { return proto.CompactTextString(m) }
func (*TLIpPortSecret) ProtoMessage()    {}
func (*TLIpPortSecret) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{16}
}
func (m *TLIpPortSecret) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLIpPortSecret) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLIpPortSecret.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLIpPortSecret) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLIpPortSecret.Merge(m, src)
}
func (m *TLIpPortSecret) XXX_Size() int {
	return m.Size()
}
func (m *TLIpPortSecret) XXX_DiscardUnknown() {
	xxx_messageInfo_TLIpPortSecret.DiscardUnknown(m)
}

var xxx_messageInfo_TLIpPortSecret proto.InternalMessageInfo

func (m *TLIpPortSecret) GetData2() *IpPort {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// MsgDetailedInfo <--
//  + TL_msg_detailed_info
//  + TL_msg_new_detailed_info
//
type MsgDetailedInfo struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	MsgId                int64    `protobuf:"varint,3,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	AnswerMsgId          int64    `protobuf:"varint,4,opt,name=answer_msg_id,json=answerMsgId,proto3" json:"answer_msg_id,omitempty"`
	Bytes                int32    `protobuf:"varint,5,opt,name=bytes,proto3" json:"bytes,omitempty"`
	Status               int32    `protobuf:"varint,6,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgDetailedInfo) Reset()         { *m = MsgDetailedInfo{} }
func (m *MsgDetailedInfo) String() string { return proto.CompactTextString(m) }
func (*MsgDetailedInfo) ProtoMessage()    {}
func (*MsgDetailedInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{17}
}
func (m *MsgDetailedInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDetailedInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDetailedInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDetailedInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDetailedInfo.Merge(m, src)
}
func (m *MsgDetailedInfo) XXX_Size() int {
	return m.Size()
}
func (m *MsgDetailedInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDetailedInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDetailedInfo proto.InternalMessageInfo

func (m *MsgDetailedInfo) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *MsgDetailedInfo) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *MsgDetailedInfo) GetMsgId() int64 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *MsgDetailedInfo) GetAnswerMsgId() int64 {
	if m != nil {
		return m.AnswerMsgId
	}
	return 0
}

func (m *MsgDetailedInfo) GetBytes() int32 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

func (m *MsgDetailedInfo) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

//  msg_detailed_info#276d3ec6 msg_id:long answer_msg_id:long bytes:int status:int = MsgDetailedInfo;
//
type TLMsgDetailedInfo struct {
	Data2                *MsgDetailedInfo `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TLMsgDetailedInfo) Reset()         { *m = TLMsgDetailedInfo{} }
func (m *TLMsgDetailedInfo) String() string { return proto.CompactTextString(m) }
func (*TLMsgDetailedInfo) ProtoMessage()    {}
func (*TLMsgDetailedInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{18}
}
func (m *TLMsgDetailedInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgDetailedInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgDetailedInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgDetailedInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgDetailedInfo.Merge(m, src)
}
func (m *TLMsgDetailedInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgDetailedInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgDetailedInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgDetailedInfo proto.InternalMessageInfo

func (m *TLMsgDetailedInfo) GetData2() *MsgDetailedInfo {
	if m != nil {
		return m.Data2
	}
	return nil
}

//  msg_new_detailed_info#809db6df answer_msg_id:long bytes:int status:int = MsgDetailedInfo;
//
type TLMsgNewDetailedInfo struct {
	Data2                *MsgDetailedInfo `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TLMsgNewDetailedInfo) Reset()         { *m = TLMsgNewDetailedInfo{} }
func (m *TLMsgNewDetailedInfo) String() string { return proto.CompactTextString(m) }
func (*TLMsgNewDetailedInfo) ProtoMessage()    {}
func (*TLMsgNewDetailedInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{19}
}
func (m *TLMsgNewDetailedInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgNewDetailedInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgNewDetailedInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgNewDetailedInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgNewDetailedInfo.Merge(m, src)
}
func (m *TLMsgNewDetailedInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgNewDetailedInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgNewDetailedInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgNewDetailedInfo proto.InternalMessageInfo

func (m *TLMsgNewDetailedInfo) GetData2() *MsgDetailedInfo {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// MsgResendReq <--
//  + TL_msg_resend_req
//
type MsgResendReq struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	MsgIds               []int64  `protobuf:"varint,3,rep,packed,name=msg_ids,json=msgIds,proto3" json:"msg_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgResendReq) Reset()         { *m = MsgResendReq{} }
func (m *MsgResendReq) String() string { return proto.CompactTextString(m) }
func (*MsgResendReq) ProtoMessage()    {}
func (*MsgResendReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{20}
}
func (m *MsgResendReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResendReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResendReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResendReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResendReq.Merge(m, src)
}
func (m *MsgResendReq) XXX_Size() int {
	return m.Size()
}
func (m *MsgResendReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResendReq.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResendReq proto.InternalMessageInfo

func (m *MsgResendReq) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *MsgResendReq) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *MsgResendReq) GetMsgIds() []int64 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

//  msg_resend_req#7d861a08 msg_ids:Vector<long> = MsgResendReq;
//
type TLMsgResendReq struct {
	Data2                *MsgResendReq `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMsgResendReq) Reset()         { *m = TLMsgResendReq{} }
func (m *TLMsgResendReq) String() string { return proto.CompactTextString(m) }
func (*TLMsgResendReq) ProtoMessage()    {}
func (*TLMsgResendReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{21}
}
func (m *TLMsgResendReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgResendReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgResendReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgResendReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgResendReq.Merge(m, src)
}
func (m *TLMsgResendReq) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgResendReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgResendReq.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgResendReq proto.InternalMessageInfo

func (m *TLMsgResendReq) GetData2() *MsgResendReq {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// MsgsAck <--
//  + TL_msgs_ack
//
type MsgsAck struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	MsgIds               []int64  `protobuf:"varint,3,rep,packed,name=msg_ids,json=msgIds,proto3" json:"msg_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgsAck) Reset()         { *m = MsgsAck{} }
func (m *MsgsAck) String() string { return proto.CompactTextString(m) }
func (*MsgsAck) ProtoMessage()    {}
func (*MsgsAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{22}
}
func (m *MsgsAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgsAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgsAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgsAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgsAck.Merge(m, src)
}
func (m *MsgsAck) XXX_Size() int {
	return m.Size()
}
func (m *MsgsAck) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgsAck.DiscardUnknown(m)
}

var xxx_messageInfo_MsgsAck proto.InternalMessageInfo

func (m *MsgsAck) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *MsgsAck) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *MsgsAck) GetMsgIds() []int64 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

//  msgs_ack#62d6b459 msg_ids:Vector<long> = MsgsAck;
//
type TLMsgsAck struct {
	Data2                *MsgsAck `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLMsgsAck) Reset()         { *m = TLMsgsAck{} }
func (m *TLMsgsAck) String() string { return proto.CompactTextString(m) }
func (*TLMsgsAck) ProtoMessage()    {}
func (*TLMsgsAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{23}
}
func (m *TLMsgsAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgsAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgsAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgsAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgsAck.Merge(m, src)
}
func (m *TLMsgsAck) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgsAck) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgsAck.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgsAck proto.InternalMessageInfo

func (m *TLMsgsAck) GetData2() *MsgsAck {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// MsgsAllInfo <--
//  + TL_msgs_all_info
//
type MsgsAllInfo struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	MsgIds               []int64  `protobuf:"varint,3,rep,packed,name=msg_ids,json=msgIds,proto3" json:"msg_ids,omitempty"`
	Info                 string   `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgsAllInfo) Reset()         { *m = MsgsAllInfo{} }
func (m *MsgsAllInfo) String() string { return proto.CompactTextString(m) }
func (*MsgsAllInfo) ProtoMessage()    {}
func (*MsgsAllInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{24}
}
func (m *MsgsAllInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgsAllInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgsAllInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgsAllInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgsAllInfo.Merge(m, src)
}
func (m *MsgsAllInfo) XXX_Size() int {
	return m.Size()
}
func (m *MsgsAllInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgsAllInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MsgsAllInfo proto.InternalMessageInfo

func (m *MsgsAllInfo) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *MsgsAllInfo) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *MsgsAllInfo) GetMsgIds() []int64 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

func (m *MsgsAllInfo) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

//  msgs_all_info#8cc0d131 msg_ids:Vector<long> info:string = MsgsAllInfo;
//
type TLMsgsAllInfo struct {
	Data2                *MsgsAllInfo `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TLMsgsAllInfo) Reset()         { *m = TLMsgsAllInfo{} }
func (m *TLMsgsAllInfo) String() string { return proto.CompactTextString(m) }
func (*TLMsgsAllInfo) ProtoMessage()    {}
func (*TLMsgsAllInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{25}
}
func (m *TLMsgsAllInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgsAllInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgsAllInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgsAllInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgsAllInfo.Merge(m, src)
}
func (m *TLMsgsAllInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgsAllInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgsAllInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgsAllInfo proto.InternalMessageInfo

func (m *TLMsgsAllInfo) GetData2() *MsgsAllInfo {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// MsgsStateInfo <--
//  + TL_msgs_state_info
//
type MsgsStateInfo struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	ReqMsgId             int64    `protobuf:"varint,3,opt,name=req_msg_id,json=reqMsgId,proto3" json:"req_msg_id,omitempty"`
	Info                 string   `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgsStateInfo) Reset()         { *m = MsgsStateInfo{} }
func (m *MsgsStateInfo) String() string { return proto.CompactTextString(m) }
func (*MsgsStateInfo) ProtoMessage()    {}
func (*MsgsStateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{26}
}
func (m *MsgsStateInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgsStateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgsStateInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgsStateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgsStateInfo.Merge(m, src)
}
func (m *MsgsStateInfo) XXX_Size() int {
	return m.Size()
}
func (m *MsgsStateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgsStateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MsgsStateInfo proto.InternalMessageInfo

func (m *MsgsStateInfo) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *MsgsStateInfo) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *MsgsStateInfo) GetReqMsgId() int64 {
	if m != nil {
		return m.ReqMsgId
	}
	return 0
}

func (m *MsgsStateInfo) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

//  msgs_state_info#04deb57d req_msg_id:long info:string = MsgsStateInfo;
//
type TLMsgsStateInfo struct {
	Data2                *MsgsStateInfo `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLMsgsStateInfo) Reset()         { *m = TLMsgsStateInfo{} }
func (m *TLMsgsStateInfo) String() string { return proto.CompactTextString(m) }
func (*TLMsgsStateInfo) ProtoMessage()    {}
func (*TLMsgsStateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{27}
}
func (m *TLMsgsStateInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgsStateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgsStateInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgsStateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgsStateInfo.Merge(m, src)
}
func (m *TLMsgsStateInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgsStateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgsStateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgsStateInfo proto.InternalMessageInfo

func (m *TLMsgsStateInfo) GetData2() *MsgsStateInfo {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// MsgsStateReq <--
//  + TL_msgs_state_req
//
type MsgsStateReq struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	MsgIds               []int64  `protobuf:"varint,3,rep,packed,name=msg_ids,json=msgIds,proto3" json:"msg_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgsStateReq) Reset()         { *m = MsgsStateReq{} }
func (m *MsgsStateReq) String() string { return proto.CompactTextString(m) }
func (*MsgsStateReq) ProtoMessage()    {}
func (*MsgsStateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{28}
}
func (m *MsgsStateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgsStateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgsStateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgsStateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgsStateReq.Merge(m, src)
}
func (m *MsgsStateReq) XXX_Size() int {
	return m.Size()
}
func (m *MsgsStateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgsStateReq.DiscardUnknown(m)
}

var xxx_messageInfo_MsgsStateReq proto.InternalMessageInfo

func (m *MsgsStateReq) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *MsgsStateReq) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *MsgsStateReq) GetMsgIds() []int64 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

//  msgs_state_req#da69fb52 msg_ids:Vector<long> = MsgsStateReq;
//
type TLMsgsStateReq struct {
	Data2                *MsgsStateReq `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMsgsStateReq) Reset()         { *m = TLMsgsStateReq{} }
func (m *TLMsgsStateReq) String() string { return proto.CompactTextString(m) }
func (*TLMsgsStateReq) ProtoMessage()    {}
func (*TLMsgsStateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{29}
}
func (m *TLMsgsStateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgsStateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgsStateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgsStateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgsStateReq.Merge(m, src)
}
func (m *TLMsgsStateReq) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgsStateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgsStateReq.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgsStateReq proto.InternalMessageInfo

func (m *TLMsgsStateReq) GetData2() *MsgsStateReq {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// NewSession <--
//  + TL_new_session_created
//
type NewSession struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	FirstMsgId           int64    `protobuf:"varint,3,opt,name=first_msg_id,json=firstMsgId,proto3" json:"first_msg_id,omitempty"`
	UniqueId             int64    `protobuf:"varint,4,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	ServerSalt           int64    `protobuf:"varint,5,opt,name=server_salt,json=serverSalt,proto3" json:"server_salt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewSession) Reset()         { *m = NewSession{} }
func (m *NewSession) String() string { return proto.CompactTextString(m) }
func (*NewSession) ProtoMessage()    {}
func (*NewSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{30}
}
func (m *NewSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewSession.Merge(m, src)
}
func (m *NewSession) XXX_Size() int {
	return m.Size()
}
func (m *NewSession) XXX_DiscardUnknown() {
	xxx_messageInfo_NewSession.DiscardUnknown(m)
}

var xxx_messageInfo_NewSession proto.InternalMessageInfo

func (m *NewSession) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *NewSession) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *NewSession) GetFirstMsgId() int64 {
	if m != nil {
		return m.FirstMsgId
	}
	return 0
}

func (m *NewSession) GetUniqueId() int64 {
	if m != nil {
		return m.UniqueId
	}
	return 0
}

func (m *NewSession) GetServerSalt() int64 {
	if m != nil {
		return m.ServerSalt
	}
	return 0
}

//  new_session_created#9ec20908 first_msg_id:long unique_id:long server_salt:long = NewSession;
//
type TLNewSessionCreated struct {
	Data2                *NewSession `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TLNewSessionCreated) Reset()         { *m = TLNewSessionCreated{} }
func (m *TLNewSessionCreated) String() string { return proto.CompactTextString(m) }
func (*TLNewSessionCreated) ProtoMessage()    {}
func (*TLNewSessionCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{31}
}
func (m *TLNewSessionCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLNewSessionCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLNewSessionCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLNewSessionCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLNewSessionCreated.Merge(m, src)
}
func (m *TLNewSessionCreated) XXX_Size() int {
	return m.Size()
}
func (m *TLNewSessionCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_TLNewSessionCreated.DiscardUnknown(m)
}

var xxx_messageInfo_TLNewSessionCreated proto.InternalMessageInfo

func (m *TLNewSessionCreated) GetData2() *NewSession {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// Pong <--
//  + TL_pong
//
type Pong struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	MsgId                int64    `protobuf:"varint,3,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	PingId               int64    `protobuf:"varint,4,opt,name=ping_id,json=pingId,proto3" json:"ping_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pong) Reset()         { *m = Pong{} }
func (m *Pong) String() string { return proto.CompactTextString(m) }
func (*Pong) ProtoMessage()    {}
func (*Pong) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{32}
}
func (m *Pong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pong.Merge(m, src)
}
func (m *Pong) XXX_Size() int {
	return m.Size()
}
func (m *Pong) XXX_DiscardUnknown() {
	xxx_messageInfo_Pong.DiscardUnknown(m)
}

var xxx_messageInfo_Pong proto.InternalMessageInfo

func (m *Pong) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *Pong) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *Pong) GetMsgId() int64 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *Pong) GetPingId() int64 {
	if m != nil {
		return m.PingId
	}
	return 0
}

//  pong#347773c5 msg_id:long ping_id:long = Pong;
//
type TLPong struct {
	Data2                *Pong    `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TLPong) Reset()         { *m = TLPong{} }
func (m *TLPong) String() string { return proto.CompactTextString(m) }
func (*TLPong) ProtoMessage()    {}
func (*TLPong) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{33}
}
func (m *TLPong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLPong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLPong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLPong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLPong.Merge(m, src)
}
func (m *TLPong) XXX_Size() int {
	return m.Size()
}
func (m *TLPong) XXX_DiscardUnknown() {
	xxx_messageInfo_TLPong.DiscardUnknown(m)
}

var xxx_messageInfo_TLPong proto.InternalMessageInfo

func (m *TLPong) GetData2() *Pong {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// RpcDropAnswer <--
//  + TL_rpc_answer_unknown
//  + TL_rpc_answer_dropped_running
//  + TL_rpc_answer_dropped
//
type RpcDropAnswer struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	MsgId                int64    `protobuf:"varint,3,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	SeqNo                int32    `protobuf:"varint,4,opt,name=seq_no,json=seqNo,proto3" json:"seq_no,omitempty"`
	Bytes                int32    `protobuf:"varint,5,opt,name=bytes,proto3" json:"bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RpcDropAnswer) Reset()         { *m = RpcDropAnswer{} }
func (m *RpcDropAnswer) String() string { return proto.CompactTextString(m) }
func (*RpcDropAnswer) ProtoMessage()    {}
func (*RpcDropAnswer) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{34}
}
func (m *RpcDropAnswer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RpcDropAnswer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RpcDropAnswer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RpcDropAnswer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RpcDropAnswer.Merge(m, src)
}
func (m *RpcDropAnswer) XXX_Size() int {
	return m.Size()
}
func (m *RpcDropAnswer) XXX_DiscardUnknown() {
	xxx_messageInfo_RpcDropAnswer.DiscardUnknown(m)
}

var xxx_messageInfo_RpcDropAnswer proto.InternalMessageInfo

func (m *RpcDropAnswer) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *RpcDropAnswer) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *RpcDropAnswer) GetMsgId() int64 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *RpcDropAnswer) GetSeqNo() int32 {
	if m != nil {
		return m.SeqNo
	}
	return 0
}

func (m *RpcDropAnswer) GetBytes() int32 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

//  rpc_answer_unknown#5e2ad36e = RpcDropAnswer;
//
type TLRpcAnswerUnknown struct {
	Data2                *RpcDropAnswer `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLRpcAnswerUnknown) Reset()         { *m = TLRpcAnswerUnknown{} }
func (m *TLRpcAnswerUnknown) String() string { return proto.CompactTextString(m) }
func (*TLRpcAnswerUnknown) ProtoMessage()    {}
func (*TLRpcAnswerUnknown) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{35}
}
func (m *TLRpcAnswerUnknown) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLRpcAnswerUnknown) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLRpcAnswerUnknown.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLRpcAnswerUnknown) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLRpcAnswerUnknown.Merge(m, src)
}
func (m *TLRpcAnswerUnknown) XXX_Size() int {
	return m.Size()
}
func (m *TLRpcAnswerUnknown) XXX_DiscardUnknown() {
	xxx_messageInfo_TLRpcAnswerUnknown.DiscardUnknown(m)
}

var xxx_messageInfo_TLRpcAnswerUnknown proto.InternalMessageInfo

func (m *TLRpcAnswerUnknown) GetData2() *RpcDropAnswer {
	if m != nil {
		return m.Data2
	}
	return nil
}

//  rpc_answer_dropped_running#cd78e586 = RpcDropAnswer;
//
type TLRpcAnswerDroppedRunning struct {
	Data2                *RpcDropAnswer `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLRpcAnswerDroppedRunning) Reset()         { *m = TLRpcAnswerDroppedRunning{} }
func (m *TLRpcAnswerDroppedRunning) String() string { return proto.CompactTextString(m) }
func (*TLRpcAnswerDroppedRunning) ProtoMessage()    {}
func (*TLRpcAnswerDroppedRunning) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{36}
}
func (m *TLRpcAnswerDroppedRunning) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLRpcAnswerDroppedRunning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLRpcAnswerDroppedRunning.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLRpcAnswerDroppedRunning) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLRpcAnswerDroppedRunning.Merge(m, src)
}
func (m *TLRpcAnswerDroppedRunning) XXX_Size() int {
	return m.Size()
}
func (m *TLRpcAnswerDroppedRunning) XXX_DiscardUnknown() {
	xxx_messageInfo_TLRpcAnswerDroppedRunning.DiscardUnknown(m)
}

var xxx_messageInfo_TLRpcAnswerDroppedRunning proto.InternalMessageInfo

func (m *TLRpcAnswerDroppedRunning) GetData2() *RpcDropAnswer {
	if m != nil {
		return m.Data2
	}
	return nil
}

//  rpc_answer_dropped#a43ad8b7 msg_id:long seq_no:int bytes:int = RpcDropAnswer;
//
type TLRpcAnswerDropped struct {
	Data2                *RpcDropAnswer `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLRpcAnswerDropped) Reset()         { *m = TLRpcAnswerDropped{} }
func (m *TLRpcAnswerDropped) String() string { return proto.CompactTextString(m) }
func (*TLRpcAnswerDropped) ProtoMessage()    {}
func (*TLRpcAnswerDropped) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{37}
}
func (m *TLRpcAnswerDropped) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLRpcAnswerDropped) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLRpcAnswerDropped.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLRpcAnswerDropped) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLRpcAnswerDropped.Merge(m, src)
}
func (m *TLRpcAnswerDropped) XXX_Size() int {
	return m.Size()
}
func (m *TLRpcAnswerDropped) XXX_DiscardUnknown() {
	xxx_messageInfo_TLRpcAnswerDropped.DiscardUnknown(m)
}

var xxx_messageInfo_TLRpcAnswerDropped proto.InternalMessageInfo

func (m *TLRpcAnswerDropped) GetData2() *RpcDropAnswer {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// RpcError <--
//  + TL_rpc_error
//
type RpcError struct {
	Cmd                  TLCmd    `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string   `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	ErrorCode            int32    `protobuf:"varint,3,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	ErrorMessage         string   `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RpcError) Reset()         { *m = RpcError{} }
func (m *RpcError) String() string { return proto.CompactTextString(m) }
func (*RpcError) ProtoMessage()    {}
func (*RpcError) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{38}
}
func (m *RpcError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RpcError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RpcError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RpcError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RpcError.Merge(m, src)
}
func (m *RpcError) XXX_Size() int {
	return m.Size()
}
func (m *RpcError) XXX_DiscardUnknown() {
	xxx_messageInfo_RpcError.DiscardUnknown(m)
}

var xxx_messageInfo_RpcError proto.InternalMessageInfo

func (m *RpcError) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *RpcError) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *RpcError) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *RpcError) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

//  rpc_error#2144ca19 error_code:int error_message:string = RpcError;
//
type TLRpcError struct {
	Data2                *RpcError `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TLRpcError) Reset()         { *m = TLRpcError{} }
func (m *TLRpcError) String() string { return proto.CompactTextString(m) }
func (*TLRpcError) ProtoMessage()    {}
func (*TLRpcError) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{39}
}
func (m *TLRpcError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLRpcError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLRpcError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLRpcError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLRpcError.Merge(m, src)
}
func (m *TLRpcError) XXX_Size() int {
	return m.Size()
}
func (m *TLRpcError) XXX_DiscardUnknown() {
	xxx_messageInfo_TLRpcError.DiscardUnknown(m)
}

var xxx_messageInfo_TLRpcError proto.InternalMessageInfo

func (m *TLRpcError) GetData2() *RpcError {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// help_ConfigSimple <--
//  + TL_help_configSimple
//
type Help_ConfigSimple struct {
	Cmd                  TLCmd              `protobuf:"varint,1,opt,name=cmd,proto3,enum=mtproto.TLCmd" json:"cmd,omitempty"`
	ClassName            string             `protobuf:"bytes,2,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	Date                 int32              `protobuf:"varint,3,opt,name=date,proto3" json:"date,omitempty"`
	Expires              int32              `protobuf:"varint,4,opt,name=expires,proto3" json:"expires,omitempty"`
	DcId                 int32              `protobuf:"varint,5,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	IpPortList           []*IpPort          `protobuf:"bytes,6,rep,name=ip_port_list,json=ipPortList,proto3" json:"ip_port_list,omitempty"`
	Rules                []*AccessPointRule `protobuf:"bytes,7,rep,name=rules,proto3" json:"rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Help_ConfigSimple) Reset()         { *m = Help_ConfigSimple{} }
func (m *Help_ConfigSimple) String() string { return proto.CompactTextString(m) }
func (*Help_ConfigSimple) ProtoMessage()    {}
func (*Help_ConfigSimple) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{40}
}
func (m *Help_ConfigSimple) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Help_ConfigSimple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Help_ConfigSimple.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Help_ConfigSimple) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Help_ConfigSimple.Merge(m, src)
}
func (m *Help_ConfigSimple) XXX_Size() int {
	return m.Size()
}
func (m *Help_ConfigSimple) XXX_DiscardUnknown() {
	xxx_messageInfo_Help_ConfigSimple.DiscardUnknown(m)
}

var xxx_messageInfo_Help_ConfigSimple proto.InternalMessageInfo

func (m *Help_ConfigSimple) GetCmd() TLCmd {
	if m != nil {
		return m.Cmd
	}
	return Cmd_UNKNOWN
}

func (m *Help_ConfigSimple) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *Help_ConfigSimple) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *Help_ConfigSimple) GetExpires() int32 {
	if m != nil {
		return m.Expires
	}
	return 0
}

func (m *Help_ConfigSimple) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

func (m *Help_ConfigSimple) GetIpPortList() []*IpPort {
	if m != nil {
		return m.IpPortList
	}
	return nil
}

func (m *Help_ConfigSimple) GetRules() []*AccessPointRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

//  help.configSimple#d997c3c5 date:int expires:int dc_id:int ip_port_list:Vector<IpPort> = help.ConfigSimple;
//  help.configSimple#5a592a6c date:int expires:int rules:vector<AccessPointRule> = help.ConfigSimple;
//
type TLHelpConfigSimple struct {
	Data2                *Help_ConfigSimple `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLHelpConfigSimple) Reset()         { *m = TLHelpConfigSimple{} }
func (m *TLHelpConfigSimple) String() string { return proto.CompactTextString(m) }
func (*TLHelpConfigSimple) ProtoMessage()    {}
func (*TLHelpConfigSimple) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{41}
}
func (m *TLHelpConfigSimple) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLHelpConfigSimple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLHelpConfigSimple.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLHelpConfigSimple) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLHelpConfigSimple.Merge(m, src)
}
func (m *TLHelpConfigSimple) XXX_Size() int {
	return m.Size()
}
func (m *TLHelpConfigSimple) XXX_DiscardUnknown() {
	xxx_messageInfo_TLHelpConfigSimple.DiscardUnknown(m)
}

var xxx_messageInfo_TLHelpConfigSimple proto.InternalMessageInfo

func (m *TLHelpConfigSimple) GetData2() *Help_ConfigSimple {
	if m != nil {
		return m.Data2
	}
	return nil
}

func init() {
	proto.RegisterType((*AccessPointRule)(nil), "mtproto.AccessPointRule")
	proto.RegisterType((*TLAccessPointRule)(nil), "mtproto.TL_accessPointRule")
	proto.RegisterType((*BadMsgNotification)(nil), "mtproto.BadMsgNotification")
	proto.RegisterType((*TLBadMsgNotification)(nil), "mtproto.TL_bad_msg_notification")
	proto.RegisterType((*TLBadServerSalt)(nil), "mtproto.TL_bad_server_salt")
	proto.RegisterType((*DestroySessionRes)(nil), "mtproto.DestroySessionRes")
	proto.RegisterType((*TLDestroySessionOk)(nil), "mtproto.TL_destroy_session_ok")
	proto.RegisterType((*TLDestroySessionNone)(nil), "mtproto.TL_destroy_session_none")
	proto.RegisterType((*FutureSalt)(nil), "mtproto.FutureSalt")
	proto.RegisterType((*TLFutureSalt)(nil), "mtproto.TL_future_salt")
	proto.RegisterType((*FutureSalts)(nil), "mtproto.FutureSalts")
	proto.RegisterType((*TLFutureSalts)(nil), "mtproto.TL_future_salts")
	proto.RegisterType((*HttpWait)(nil), "mtproto.HttpWait")
	proto.RegisterType((*TLHttpWait)(nil), "mtproto.TL_http_wait")
	proto.RegisterType((*IpPort)(nil), "mtproto.IpPort")
	proto.RegisterType((*TLIpPort)(nil), "mtproto.TL_ipPort")
	proto.RegisterType((*TLIpPortSecret)(nil), "mtproto.TL_ipPortSecret")
	proto.RegisterType((*MsgDetailedInfo)(nil), "mtproto.MsgDetailedInfo")
	proto.RegisterType((*TLMsgDetailedInfo)(nil), "mtproto.TL_msg_detailed_info")
	proto.RegisterType((*TLMsgNewDetailedInfo)(nil), "mtproto.TL_msg_new_detailed_info")
	proto.RegisterType((*MsgResendReq)(nil), "mtproto.MsgResendReq")
	proto.RegisterType((*TLMsgResendReq)(nil), "mtproto.TL_msg_resend_req")
	proto.RegisterType((*MsgsAck)(nil), "mtproto.MsgsAck")
	proto.RegisterType((*TLMsgsAck)(nil), "mtproto.TL_msgs_ack")
	proto.RegisterType((*MsgsAllInfo)(nil), "mtproto.MsgsAllInfo")
	proto.RegisterType((*TLMsgsAllInfo)(nil), "mtproto.TL_msgs_all_info")
	proto.RegisterType((*MsgsStateInfo)(nil), "mtproto.MsgsStateInfo")
	proto.RegisterType((*TLMsgsStateInfo)(nil), "mtproto.TL_msgs_state_info")
	proto.RegisterType((*MsgsStateReq)(nil), "mtproto.MsgsStateReq")
	proto.RegisterType((*TLMsgsStateReq)(nil), "mtproto.TL_msgs_state_req")
	proto.RegisterType((*NewSession)(nil), "mtproto.NewSession")
	proto.RegisterType((*TLNewSessionCreated)(nil), "mtproto.TL_new_session_created")
	proto.RegisterType((*Pong)(nil), "mtproto.Pong")
	proto.RegisterType((*TLPong)(nil), "mtproto.TL_pong")
	proto.RegisterType((*RpcDropAnswer)(nil), "mtproto.RpcDropAnswer")
	proto.RegisterType((*TLRpcAnswerUnknown)(nil), "mtproto.TL_rpc_answer_unknown")
	proto.RegisterType((*TLRpcAnswerDroppedRunning)(nil), "mtproto.TL_rpc_answer_dropped_running")
	proto.RegisterType((*TLRpcAnswerDropped)(nil), "mtproto.TL_rpc_answer_dropped")
	proto.RegisterType((*RpcError)(nil), "mtproto.RpcError")
	proto.RegisterType((*TLRpcError)(nil), "mtproto.TL_rpc_error")
	proto.RegisterType((*Help_ConfigSimple)(nil), "mtproto.help_ConfigSimple")
	proto.RegisterType((*TLHelpConfigSimple)(nil), "mtproto.TL_help_configSimple")
}

func init() { proto.RegisterFile("schema.tl.transport.proto", fileDescriptor_253819edc71e8ec7) }

var fileDescriptor_253819edc71e8ec7 = []byte{
	// 1390 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xd7, 0xe2, 0x7f, 0xf1, 0x73, 0xd2, 0x24, 0xdb, 0xa6, 0x71, 0x5b, 0x1a, 0xc2, 0x56, 0x94,
	0x00, 0xad, 0x4b, 0x03, 0x08, 0x24, 0x04, 0x22, 0x4d, 0x5a, 0x6a, 0x70, 0xa2, 0x68, 0x6d, 0x84,
	0xc4, 0x65, 0x34, 0xd9, 0x1d, 0x3b, 0xa3, 0xec, 0xce, 0xac, 0x67, 0xc6, 0x75, 0x2a, 0x6e, 0xdc,
	0x38, 0x71, 0xe1, 0x13, 0xc0, 0x99, 0x3b, 0x12, 0x5f, 0x80, 0x23, 0x9f, 0x00, 0x41, 0x3f, 0x01,
	0x67, 0x4e, 0x68, 0x66, 0x76, 0x6d, 0x6f, 0x12, 0x17, 0x5a, 0xa7, 0x9c, 0x3c, 0xf3, 0x9b, 0xd9,
	0xf7, 0x7e, 0xbf, 0x37, 0xff, 0xde, 0x33, 0x5c, 0x91, 0xc1, 0x21, 0x89, 0x71, 0x43, 0x45, 0x0d,
	0x25, 0x30, 0x93, 0x09, 0x17, 0xaa, 0x91, 0x08, 0xae, 0xb8, 0x5b, 0x89, 0x95, 0x69, 0x5c, 0xbd,
	0xdd, 0xa3, 0xea, 0x70, 0x70, 0xd0, 0x08, 0x78, 0x7c, 0xa7, 0xc7, 0x7b, 0xfc, 0x8e, 0x81, 0x0f,
	0x06, 0x5d, 0xd3, 0x33, 0x1d, 0xd3, 0xb2, 0xdf, 0x5d, 0xbd, 0x38, 0x36, 0x19, 0xc4, 0xa1, 0x05,
	0xbd, 0x9f, 0x1d, 0x58, 0xdc, 0x0a, 0x02, 0x22, 0xe5, 0x3e, 0xa7, 0x4c, 0xf9, 0x83, 0x88, 0xb8,
	0xeb, 0x50, 0x08, 0xe2, 0xb0, 0xee, 0xac, 0x3b, 0x1b, 0x17, 0x36, 0x2f, 0x34, 0x52, 0x77, 0x8d,
	0x4e, 0x6b, 0x3b, 0x0e, 0x7d, 0x3d, 0xe4, 0x5e, 0x07, 0x08, 0x22, 0x2c, 0x25, 0x62, 0x38, 0x26,
	0xf5, 0x97, 0xd6, 0x9d, 0x8d, 0xaa, 0x5f, 0x35, 0xc8, 0x1e, 0x8e, 0x89, 0x7b, 0x0b, 0xdc, 0xe4,
	0x90, 0x33, 0x82, 0x12, 0x41, 0xba, 0xf4, 0x18, 0x89, 0x41, 0x44, 0x64, 0xbd, 0x60, 0xa6, 0x2d,
	0x99, 0x91, 0x7d, 0x33, 0xa0, 0xbd, 0x49, 0xf7, 0x22, 0x94, 0xc2, 0x00, 0xd1, 0xb0, 0x5e, 0x5c,
	0x77, 0x36, 0x4a, 0x7e, 0x31, 0x0c, 0x9a, 0xa1, 0xfb, 0x2a, 0x14, 0x68, 0x22, 0xeb, 0xa5, 0xf5,
	0xc2, 0x46, 0x6d, 0x73, 0x71, 0xc4, 0xa1, 0x99, 0xec, 0x73, 0xa1, 0x7c, 0x3d, 0xe6, 0xed, 0x80,
	0xdb, 0x69, 0x21, 0x7c, 0x82, 0x7c, 0x03, 0x4a, 0x21, 0x56, 0x78, 0xd3, 0xd0, 0xaf, 0x6d, 0xd6,
	0x47, 0x9f, 0x9e, 0x50, 0xe9, 0xdb, 0x69, 0xde, 0xef, 0x0e, 0xb8, 0xf7, 0x70, 0xb8, 0x2b, 0x7b,
	0x7b, 0x5c, 0xd1, 0x2e, 0x0d, 0xb0, 0xa2, 0x9c, 0xcd, 0x1e, 0x83, 0x97, 0x01, 0x0e, 0x70, 0x88,
	0x62, 0xd9, 0xd3, 0xd2, 0xb4, 0xf6, 0x82, 0x3f, 0x77, 0x60, 0x1c, 0x35, 0x43, 0xd7, 0x83, 0x85,
	0x6c, 0x54, 0x92, 0x3e, 0xe3, 0xa9, 0xf6, 0x9a, 0x9d, 0xd0, 0xd6, 0x90, 0x76, 0x40, 0x84, 0xe0,
	0x02, 0x05, 0x3c, 0x24, 0xf5, 0x92, 0x99, 0x50, 0x35, 0xc8, 0x36, 0x0f, 0x89, 0x7b, 0x13, 0x16,
	0x19, 0x19, 0x22, 0x49, 0xc4, 0x23, 0x22, 0x90, 0xc4, 0x91, 0xaa, 0x97, 0x8d, 0x97, 0x05, 0x46,
	0x86, 0x6d, 0x83, 0xb6, 0x71, 0xa4, 0xbc, 0x16, 0xac, 0x76, 0x5a, 0x28, 0xf3, 0xc6, 0x26, 0x45,
	0xde, 0xcd, 0xc7, 0xea, 0xda, 0x48, 0xe6, 0xe9, 0x80, 0x64, 0xe1, 0xfa, 0xd4, 0x04, 0x5d, 0x5b,
	0x9b, 0x70, 0xfc, 0x3c, 0x86, 0x24, 0x2c, 0xef, 0x10, 0xa9, 0x04, 0x7f, 0xdc, 0x26, 0x52, 0xea,
	0x01, 0x22, 0x67, 0x8f, 0xfa, 0x75, 0x00, 0x69, 0xcd, 0x8d, 0xa3, 0x5e, 0x4d, 0x91, 0x66, 0xe8,
	0x35, 0x61, 0xa5, 0xd3, 0x42, 0xa1, 0xf5, 0x8b, 0xb2, 0x99, 0xfc, 0xc8, 0x7d, 0x3b, 0x2f, 0xe0,
	0xea, 0xc8, 0xf5, 0x29, 0x8e, 0x19, 0xff, 0xcf, 0x4d, 0x58, 0x4f, 0x9a, 0x62, 0x9c, 0x91, 0xe7,
	0x30, 0xf6, 0xa3, 0x03, 0xf0, 0x60, 0xa0, 0x06, 0x82, 0xe8, 0x25, 0x9b, 0x3d, 0x0c, 0xaf, 0x40,
	0xed, 0x11, 0x8e, 0x68, 0x88, 0x24, 0x65, 0x01, 0x31, 0x71, 0x28, 0xf9, 0x60, 0xa0, 0xb6, 0x46,
	0xc6, 0x13, 0x06, 0x4c, 0xd1, 0x28, 0xdd, 0x7d, 0x76, 0xc2, 0x17, 0x1a, 0x71, 0x5d, 0x28, 0x9a,
	0x2d, 0x55, 0x32, 0x21, 0x34, 0x6d, 0xef, 0x43, 0xb8, 0xd0, 0x69, 0xa1, 0xae, 0xe1, 0x69, 0xd7,
	0xfd, 0x8d, 0xbc, 0xd2, 0x8b, 0x23, 0xaa, 0x63, 0x31, 0x99, 0xc4, 0x9f, 0x1c, 0xa8, 0x8d, 0x51,
	0x79, 0x2e, 0x07, 0x4c, 0x90, 0xfe, 0x89, 0x03, 0x26, 0x48, 0xdf, 0x1e, 0xb0, 0x25, 0x28, 0x30,
	0x3e, 0x4c, 0x85, 0xe9, 0xa6, 0x7b, 0x1b, 0x4a, 0x9a, 0x73, 0x76, 0xa7, 0xac, 0x4e, 0xb8, 0x9c,
	0xd4, 0xe4, 0xdb, 0x59, 0xde, 0x47, 0xb0, 0x98, 0x1f, 0x90, 0xee, 0x9b, 0x79, 0xb5, 0x97, 0xce,
	0x50, 0x3b, 0x5a, 0xd1, 0x1f, 0x1c, 0x98, 0x7b, 0xa8, 0x54, 0xf2, 0x25, 0xa6, 0xe7, 0xb0, 0x9e,
	0xd7, 0xa0, 0x1a, 0xe3, 0x63, 0x14, 0x92, 0x08, 0x3f, 0x4e, 0x57, 0x73, 0x2e, 0xc6, 0xc7, 0x3b,
	0xba, 0xaf, 0xbf, 0x1d, 0x62, 0xaa, 0x10, 0xee, 0x2a, 0x22, 0x52, 0xc5, 0x55, 0x8d, 0x6c, 0x69,
	0xc0, 0xbd, 0x02, 0x7a, 0x2a, 0xd2, 0x40, 0x7a, 0x89, 0x54, 0x62, 0x7c, 0xac, 0x79, 0x79, 0xef,
	0xc3, 0x7c, 0xa7, 0x85, 0x0e, 0x95, 0x4a, 0xcc, 0xb0, 0xfb, 0x7a, 0x5e, 0xe0, 0xf2, 0x88, 0x69,
	0xa6, 0x24, 0x53, 0xf7, 0xad, 0x03, 0x65, 0x7b, 0x15, 0xcf, 0xae, 0xcd, 0x85, 0x22, 0x4d, 0x1e,
	0xbd, 0x9b, 0xca, 0x32, 0x6d, 0x8d, 0xe9, 0x07, 0x2f, 0x7b, 0x11, 0x74, 0xdb, 0xbd, 0x0c, 0x65,
	0x49, 0x02, 0x41, 0xac, 0x8a, 0x79, 0x3f, 0xed, 0x79, 0x9b, 0x50, 0xed, 0xb4, 0x10, 0xb5, 0x6c,
	0x5e, 0xcb, 0x2b, 0x38, 0xf5, 0x70, 0xa4, 0xfc, 0x3f, 0x30, 0x8b, 0x6b, 0xbf, 0x69, 0x1b, 0x33,
	0xff, 0xf5, 0xcb, 0x5f, 0x1c, 0x58, 0xdc, 0x95, 0xbd, 0x1d, 0xa2, 0x30, 0x8d, 0x48, 0xd8, 0x64,
	0x5d, 0x3e, 0x7b, 0x08, 0x56, 0xa0, 0x9c, 0xdb, 0xc6, 0xa5, 0x38, 0x7b, 0x24, 0x30, 0x93, 0x43,
	0x22, 0xb2, 0x4d, 0x5e, 0x34, 0xa3, 0x35, 0x0b, 0xda, 0x7d, 0x7e, 0x09, 0x4a, 0x07, 0x8f, 0x15,
	0x91, 0xe9, 0xd2, 0xda, 0x8e, 0x89, 0x95, 0xc2, 0x6a, 0x20, 0xcd, 0x93, 0x50, 0xf2, 0xd3, 0x9e,
	0xf7, 0x00, 0x2e, 0x75, 0x5a, 0xc6, 0x5a, 0x98, 0x0a, 0x40, 0x54, 0x2b, 0x98, 0xfa, 0x68, 0x9e,
	0x90, 0x9a, 0x45, 0xe1, 0x33, 0xa8, 0xa7, 0x76, 0xf4, 0x13, 0x34, 0x9b, 0xad, 0x43, 0x98, 0xdf,
	0x95, 0x3d, 0x9f, 0x48, 0xc2, 0x42, 0x9f, 0xf4, 0x67, 0x8f, 0xe6, 0x2a, 0x54, 0x6c, 0xbc, 0x74,
	0xca, 0x51, 0xd8, 0x28, 0xf8, 0x65, 0x13, 0x4e, 0xe9, 0x7d, 0x02, 0xcb, 0x29, 0x6b, 0x61, 0xbc,
	0x21, 0x41, 0xfa, 0xee, 0x5b, 0x79, 0xba, 0x2b, 0x93, 0x74, 0x47, 0xa4, 0x32, 0xae, 0x01, 0x54,
	0x76, 0x65, 0x4f, 0x6e, 0x05, 0x47, 0x2f, 0x90, 0xe6, 0x7b, 0x50, 0xb3, 0x34, 0x25, 0xc2, 0xc1,
	0x91, 0x7b, 0x33, 0x4f, 0x70, 0x69, 0x92, 0xa0, 0x66, 0x92, 0x71, 0xfb, 0x1a, 0x6a, 0x06, 0x89,
	0xa2, 0xf3, 0xd9, 0x94, 0xd3, 0xf8, 0x99, 0x03, 0xcb, 0xba, 0x36, 0x65, 0xa9, 0xfa, 0xa6, 0xed,
	0x7d, 0x0c, 0x4b, 0x23, 0xce, 0x51, 0x64, 0x37, 0xc2, 0xd4, 0xeb, 0x72, 0x82, 0x66, 0x46, 0xfe,
	0x1b, 0x07, 0x16, 0x34, 0xdc, 0x56, 0x58, 0x91, 0xf3, 0xe1, 0xff, 0xf4, 0xf7, 0xe1, 0x2c, 0x11,
	0xf7, 0x4c, 0x6e, 0x63, 0x44, 0xe8, 0xf3, 0x42, 0xac, 0x8c, 0x5b, 0x79, 0x19, 0x97, 0x73, 0x32,
	0x46, 0x7c, 0xf3, 0xbb, 0xd9, 0xe2, 0xff, 0xd3, 0x6e, 0xce, 0xd8, 0xfe, 0xdb, 0x6e, 0x1e, 0x91,
	0x9a, 0x78, 0x92, 0x61, 0x4f, 0xe7, 0x8a, 0x26, 0x1d, 0x99, 0x9d, 0xea, 0x3a, 0xcc, 0x77, 0xa9,
	0x90, 0x2a, 0x1f, 0x73, 0x30, 0x98, 0x8d, 0xfa, 0x35, 0xa8, 0x0e, 0x18, 0xed, 0x0f, 0xc8, 0xf8,
	0x36, 0x9b, 0xb3, 0x40, 0x33, 0xd4, 0x39, 0xc9, 0x64, 0x32, 0x6b, 0x33, 0x0f, 0x90, 0xe3, 0x4c,
	0x76, 0x1b, 0x2e, 0x77, 0x5a, 0xc8, 0x26, 0xbd, 0x36, 0xdd, 0x0a, 0x04, 0xc1, 0x8a, 0x84, 0xd3,
	0xf3, 0x90, 0xb1, 0xbc, 0x4c, 0xf4, 0x10, 0x8a, 0xfb, 0x9c, 0xf5, 0x5e, 0xd8, 0xa5, 0xbd, 0x0a,
	0x95, 0x84, 0xb2, 0x89, 0xeb, 0xba, 0xac, 0xbb, 0xcd, 0xd0, 0x6b, 0x40, 0xa5, 0xd3, 0x42, 0x89,
	0xf6, 0x7d, 0x23, 0x4f, 0x77, 0x61, 0xe4, 0x5d, 0x33, 0xcb, 0x88, 0x7e, 0xef, 0xc0, 0x82, 0x9f,
	0x04, 0x3b, 0x82, 0x27, 0x5b, 0xe6, 0xc2, 0x7f, 0x61, 0x94, 0x57, 0xf4, 0xcb, 0xda, 0x47, 0xa3,
	0x2a, 0xa4, 0x24, 0x49, 0x7f, 0x8f, 0x9f, 0xfd, 0xb4, 0x78, 0xf7, 0x4d, 0x0a, 0x2d, 0x92, 0x00,
	0xa5, 0x6f, 0xd3, 0x80, 0x1d, 0x31, 0x3e, 0x64, 0xd3, 0xcf, 0x49, 0x4e, 0x44, 0xa6, 0x6e, 0x17,
	0xae, 0xe7, 0xcd, 0x84, 0x82, 0x27, 0x09, 0x09, 0x91, 0x18, 0x30, 0x46, 0x59, 0xef, 0x19, 0xcd,
	0x9d, 0x62, 0x95, 0x9a, 0x7b, 0x46, 0x33, 0xdf, 0x39, 0x30, 0xe7, 0x27, 0xc1, 0x7d, 0x5d, 0x64,
	0x9d, 0x4b, 0x31, 0x32, 0x51, 0xc0, 0x15, 0x4e, 0x16, 0x70, 0x37, 0x60, 0xc1, 0x0e, 0xc7, 0x44,
	0x4a, 0xdc, 0x23, 0xe9, 0x5d, 0x34, 0x6f, 0xc0, 0x5d, 0x8b, 0xa5, 0x29, 0x9a, 0x16, 0x66, 0xe0,
	0xe9, 0x29, 0x5a, 0x46, 0x3b, 0x93, 0xf2, 0xb7, 0x03, 0xcb, 0x87, 0x24, 0x4a, 0xd0, 0x36, 0x67,
	0x5d, 0xda, 0x6b, 0xd3, 0x38, 0x39, 0x8f, 0xd2, 0xde, 0x85, 0x62, 0x88, 0x55, 0xa6, 0xc6, 0xb4,
	0xdd, 0x3a, 0x54, 0xc8, 0x71, 0x42, 0x05, 0x91, 0xe9, 0x06, 0xca, 0xba, 0xe3, 0xd2, 0xbe, 0x34,
	0x51, 0xda, 0xdf, 0x85, 0x79, 0x9a, 0x20, 0x9d, 0xd3, 0xa1, 0x88, 0x4a, 0x5d, 0xb5, 0x9e, 0x59,
	0xe3, 0x83, 0x4d, 0xcf, 0x5a, 0x54, 0x2a, 0x9d, 0x53, 0xd8, 0xff, 0x10, 0x2a, 0x66, 0xee, 0x53,
	0x8a, 0x7a, 0x33, 0xcd, 0x7b, 0x68, 0xf2, 0x1c, 0x23, 0x3f, 0x98, 0x94, 0x3f, 0xb5, 0x32, 0x3b,
	0x15, 0xa9, 0x34, 0x8c, 0xf7, 0xae, 0xfc, 0xf5, 0xe7, 0x9a, 0xf3, 0xeb, 0x93, 0x35, 0xe7, 0xb7,
	0x27, 0x6b, 0xce, 0x1f, 0x4f, 0xd6, 0x9c, 0xaf, 0xb2, 0xbf, 0x5f, 0x0e, 0xca, 0xe6, 0xe7, 0x9d,
	0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xad, 0x57, 0x54, 0xe6, 0xab, 0x11, 0x00, 0x00,
}

func (this *AccessPointRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mtproto.AccessPointRule{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "PhonePrefixRules: "+fmt.Sprintf("%#v", this.PhonePrefixRules)+",\n")
	s = append(s, "DcId: "+fmt.Sprintf("%#v", this.DcId)+",\n")
	if this.Ips != nil {
		s = append(s, "Ips: "+fmt.Sprintf("%#v", this.Ips)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAccessPointRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLAccessPointRule{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BadMsgNotification) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&mtproto.BadMsgNotification{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "BadMsgId: "+fmt.Sprintf("%#v", this.BadMsgId)+",\n")
	s = append(s, "BadMsgSeqno: "+fmt.Sprintf("%#v", this.BadMsgSeqno)+",\n")
	s = append(s, "ErrorCode: "+fmt.Sprintf("%#v", this.ErrorCode)+",\n")
	s = append(s, "NewServerSalt: "+fmt.Sprintf("%#v", this.NewServerSalt)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLBadMsgNotification) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLBadMsgNotification{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLBadServerSalt) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLBadServerSalt{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DestroySessionRes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mtproto.DestroySessionRes{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "SessionId: "+fmt.Sprintf("%#v", this.SessionId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLDestroySessionOk) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLDestroySessionOk{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLDestroySessionNone) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLDestroySessionNone{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FutureSalt) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mtproto.FutureSalt{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "ValidSince: "+fmt.Sprintf("%#v", this.ValidSince)+",\n")
	s = append(s, "ValidUntil: "+fmt.Sprintf("%#v", this.ValidUntil)+",\n")
	s = append(s, "Salt: "+fmt.Sprintf("%#v", this.Salt)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLFutureSalt) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLFutureSalt{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FutureSalts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mtproto.FutureSalts{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "ReqMsgId: "+fmt.Sprintf("%#v", this.ReqMsgId)+",\n")
	s = append(s, "Now: "+fmt.Sprintf("%#v", this.Now)+",\n")
	if this.Salts != nil {
		s = append(s, "Salts: "+fmt.Sprintf("%#v", this.Salts)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLFutureSalts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLFutureSalts{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HttpWait) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mtproto.HttpWait{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "MaxDelay: "+fmt.Sprintf("%#v", this.MaxDelay)+",\n")
	s = append(s, "WaitAfter: "+fmt.Sprintf("%#v", this.WaitAfter)+",\n")
	s = append(s, "MaxWait: "+fmt.Sprintf("%#v", this.MaxWait)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLHttpWait) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLHttpWait{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mtproto.IpPort{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "Ipv4: "+fmt.Sprintf("%#v", this.Ipv4)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Secret: "+fmt.Sprintf("%#v", this.Secret)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLIpPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLIpPort{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLIpPortSecret) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLIpPortSecret{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MsgDetailedInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&mtproto.MsgDetailedInfo{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "MsgId: "+fmt.Sprintf("%#v", this.MsgId)+",\n")
	s = append(s, "AnswerMsgId: "+fmt.Sprintf("%#v", this.AnswerMsgId)+",\n")
	s = append(s, "Bytes: "+fmt.Sprintf("%#v", this.Bytes)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMsgDetailedInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLMsgDetailedInfo{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMsgNewDetailedInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLMsgNewDetailedInfo{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MsgResendReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mtproto.MsgResendReq{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "MsgIds: "+fmt.Sprintf("%#v", this.MsgIds)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMsgResendReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLMsgResendReq{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MsgsAck) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mtproto.MsgsAck{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "MsgIds: "+fmt.Sprintf("%#v", this.MsgIds)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMsgsAck) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLMsgsAck{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MsgsAllInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mtproto.MsgsAllInfo{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "MsgIds: "+fmt.Sprintf("%#v", this.MsgIds)+",\n")
	s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMsgsAllInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLMsgsAllInfo{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MsgsStateInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mtproto.MsgsStateInfo{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "ReqMsgId: "+fmt.Sprintf("%#v", this.ReqMsgId)+",\n")
	s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMsgsStateInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLMsgsStateInfo{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MsgsStateReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mtproto.MsgsStateReq{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "MsgIds: "+fmt.Sprintf("%#v", this.MsgIds)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMsgsStateReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLMsgsStateReq{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NewSession) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mtproto.NewSession{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "FirstMsgId: "+fmt.Sprintf("%#v", this.FirstMsgId)+",\n")
	s = append(s, "UniqueId: "+fmt.Sprintf("%#v", this.UniqueId)+",\n")
	s = append(s, "ServerSalt: "+fmt.Sprintf("%#v", this.ServerSalt)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLNewSessionCreated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLNewSessionCreated{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Pong) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mtproto.Pong{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "MsgId: "+fmt.Sprintf("%#v", this.MsgId)+",\n")
	s = append(s, "PingId: "+fmt.Sprintf("%#v", this.PingId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLPong) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLPong{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RpcDropAnswer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mtproto.RpcDropAnswer{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "MsgId: "+fmt.Sprintf("%#v", this.MsgId)+",\n")
	s = append(s, "SeqNo: "+fmt.Sprintf("%#v", this.SeqNo)+",\n")
	s = append(s, "Bytes: "+fmt.Sprintf("%#v", this.Bytes)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLRpcAnswerUnknown) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLRpcAnswerUnknown{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLRpcAnswerDroppedRunning) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLRpcAnswerDroppedRunning{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLRpcAnswerDropped) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLRpcAnswerDropped{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RpcError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mtproto.RpcError{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "ErrorCode: "+fmt.Sprintf("%#v", this.ErrorCode)+",\n")
	s = append(s, "ErrorMessage: "+fmt.Sprintf("%#v", this.ErrorMessage)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLRpcError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLRpcError{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Help_ConfigSimple) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&mtproto.Help_ConfigSimple{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "ClassName: "+fmt.Sprintf("%#v", this.ClassName)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "Expires: "+fmt.Sprintf("%#v", this.Expires)+",\n")
	s = append(s, "DcId: "+fmt.Sprintf("%#v", this.DcId)+",\n")
	if this.IpPortList != nil {
		s = append(s, "IpPortList: "+fmt.Sprintf("%#v", this.IpPortList)+",\n")
	}
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLHelpConfigSimple) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mtproto.TLHelpConfigSimple{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringSchemaTlTransport(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AccessPointRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessPointRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessPointRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ips) > 0 {
		for iNdEx := len(m.Ips) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ips[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DcId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.DcId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.PhonePrefixRules) > 0 {
		i -= len(m.PhonePrefixRules)
		copy(dAtA[i:], m.PhonePrefixRules)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.PhonePrefixRules)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAccessPointRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAccessPointRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAccessPointRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BadMsgNotification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BadMsgNotification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BadMsgNotification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NewServerSalt != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.NewServerSalt))
		i--
		dAtA[i] = 0x30
	}
	if m.ErrorCode != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x28
	}
	if m.BadMsgSeqno != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.BadMsgSeqno))
		i--
		dAtA[i] = 0x20
	}
	if m.BadMsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.BadMsgId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLBadMsgNotification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLBadMsgNotification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLBadMsgNotification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLBadServerSalt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLBadServerSalt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLBadServerSalt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DestroySessionRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DestroySessionRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DestroySessionRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SessionId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.SessionId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLDestroySessionOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDestroySessionOk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDestroySessionOk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLDestroySessionNone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDestroySessionNone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDestroySessionNone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FutureSalt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FutureSalt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FutureSalt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Salt != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Salt))
		i--
		dAtA[i] = 0x28
	}
	if m.ValidUntil != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ValidUntil))
		i--
		dAtA[i] = 0x20
	}
	if m.ValidSince != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ValidSince))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLFutureSalt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLFutureSalt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLFutureSalt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FutureSalts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FutureSalts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FutureSalts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Salts) > 0 {
		for iNdEx := len(m.Salts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Salts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Now != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Now))
		i--
		dAtA[i] = 0x20
	}
	if m.ReqMsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ReqMsgId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLFutureSalts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLFutureSalts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLFutureSalts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpWait) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpWait) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpWait) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxWait != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.MaxWait))
		i--
		dAtA[i] = 0x28
	}
	if m.WaitAfter != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.WaitAfter))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxDelay != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.MaxDelay))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLHttpWait) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLHttpWait) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLHttpWait) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Secret) > 0 {
		i -= len(m.Secret)
		copy(dAtA[i:], m.Secret)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.Secret)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Port != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x20
	}
	if m.Ipv4 != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Ipv4))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLIpPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLIpPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLIpPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLIpPortSecret) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLIpPortSecret) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLIpPortSecret) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDetailedInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDetailedInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDetailedInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.Bytes != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Bytes))
		i--
		dAtA[i] = 0x28
	}
	if m.AnswerMsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.AnswerMsgId))
		i--
		dAtA[i] = 0x20
	}
	if m.MsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.MsgId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgDetailedInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgDetailedInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgDetailedInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgNewDetailedInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgNewDetailedInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgNewDetailedInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResendReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResendReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResendReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MsgIds) > 0 {
		dAtA14 := make([]byte, len(m.MsgIds)*10)
		var j13 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgResendReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgResendReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgResendReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgsAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgsAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgsAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MsgIds) > 0 {
		dAtA17 := make([]byte, len(m.MsgIds)*10)
		var j16 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgsAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgsAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgsAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgsAllInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgsAllInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgsAllInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MsgIds) > 0 {
		dAtA20 := make([]byte, len(m.MsgIds)*10)
		var j19 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgsAllInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgsAllInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgsAllInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgsStateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgsStateInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgsStateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x22
	}
	if m.ReqMsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ReqMsgId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgsStateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgsStateInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgsStateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgsStateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgsStateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgsStateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MsgIds) > 0 {
		dAtA24 := make([]byte, len(m.MsgIds)*10)
		var j23 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgsStateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgsStateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgsStateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NewSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ServerSalt != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ServerSalt))
		i--
		dAtA[i] = 0x28
	}
	if m.UniqueId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.UniqueId))
		i--
		dAtA[i] = 0x20
	}
	if m.FirstMsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.FirstMsgId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLNewSessionCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLNewSessionCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLNewSessionCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pong) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pong) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PingId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.PingId))
		i--
		dAtA[i] = 0x20
	}
	if m.MsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.MsgId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLPong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLPong) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLPong) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RpcDropAnswer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcDropAnswer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RpcDropAnswer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Bytes != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Bytes))
		i--
		dAtA[i] = 0x28
	}
	if m.SeqNo != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.SeqNo))
		i--
		dAtA[i] = 0x20
	}
	if m.MsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.MsgId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLRpcAnswerUnknown) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLRpcAnswerUnknown) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLRpcAnswerUnknown) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLRpcAnswerDroppedRunning) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLRpcAnswerDroppedRunning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLRpcAnswerDroppedRunning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLRpcAnswerDropped) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLRpcAnswerDropped) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLRpcAnswerDropped) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RpcError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RpcError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x22
	}
	if m.ErrorCode != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLRpcError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLRpcError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLRpcError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Help_ConfigSimple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Help_ConfigSimple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Help_ConfigSimple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.IpPortList) > 0 {
		for iNdEx := len(m.IpPortList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IpPortList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.DcId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.DcId))
		i--
		dAtA[i] = 0x28
	}
	if m.Expires != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Expires))
		i--
		dAtA[i] = 0x20
	}
	if m.Date != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLHelpConfigSimple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLHelpConfigSimple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLHelpConfigSimple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSchemaTlTransport(dAtA []byte, offset int, v uint64) int {
	offset -= sovSchemaTlTransport(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AccessPointRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	l = len(m.PhonePrefixRules)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.DcId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.DcId))
	}
	if len(m.Ips) > 0 {
		for _, e := range m.Ips {
			l = e.Size()
			n += 1 + l + sovSchemaTlTransport(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAccessPointRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BadMsgNotification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.BadMsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.BadMsgId))
	}
	if m.BadMsgSeqno != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.BadMsgSeqno))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ErrorCode))
	}
	if m.NewServerSalt != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.NewServerSalt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLBadMsgNotification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLBadServerSalt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DestroySessionRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.SessionId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.SessionId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLDestroySessionOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLDestroySessionNone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FutureSalt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.ValidSince != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ValidSince))
	}
	if m.ValidUntil != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ValidUntil))
	}
	if m.Salt != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Salt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLFutureSalt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FutureSalts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.ReqMsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ReqMsgId))
	}
	if m.Now != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Now))
	}
	if len(m.Salts) > 0 {
		for _, e := range m.Salts {
			l = e.Size()
			n += 1 + l + sovSchemaTlTransport(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLFutureSalts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpWait) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.MaxDelay != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.MaxDelay))
	}
	if m.WaitAfter != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.WaitAfter))
	}
	if m.MaxWait != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.MaxWait))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLHttpWait) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IpPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.Ipv4 != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Ipv4))
	}
	if m.Port != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Port))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLIpPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLIpPortSecret) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgDetailedInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.MsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.MsgId))
	}
	if m.AnswerMsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.AnswerMsgId))
	}
	if m.Bytes != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Bytes))
	}
	if m.Status != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMsgDetailedInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMsgNewDetailedInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgResendReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovSchemaTlTransport(uint64(e))
		}
		n += 1 + sovSchemaTlTransport(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMsgResendReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgsAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovSchemaTlTransport(uint64(e))
		}
		n += 1 + sovSchemaTlTransport(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMsgsAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgsAllInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovSchemaTlTransport(uint64(e))
		}
		n += 1 + sovSchemaTlTransport(uint64(l)) + l
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMsgsAllInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgsStateInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.ReqMsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ReqMsgId))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMsgsStateInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgsStateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovSchemaTlTransport(uint64(e))
		}
		n += 1 + sovSchemaTlTransport(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMsgsStateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.FirstMsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.FirstMsgId))
	}
	if m.UniqueId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.UniqueId))
	}
	if m.ServerSalt != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ServerSalt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLNewSessionCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.MsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.MsgId))
	}
	if m.PingId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.PingId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLPong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpcDropAnswer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.MsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.MsgId))
	}
	if m.SeqNo != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.SeqNo))
	}
	if m.Bytes != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Bytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLRpcAnswerUnknown) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLRpcAnswerDroppedRunning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLRpcAnswerDropped) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RpcError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ErrorCode))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLRpcError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Help_ConfigSimple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Cmd))
	}
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.Date != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Date))
	}
	if m.Expires != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Expires))
	}
	if m.DcId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.DcId))
	}
	if len(m.IpPortList) > 0 {
		for _, e := range m.IpPortList {
			l = e.Size()
			n += 1 + l + sovSchemaTlTransport(uint64(l))
		}
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovSchemaTlTransport(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLHelpConfigSimple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSchemaTlTransport(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSchemaTlTransport(x uint64) (n int) {
	return sovSchemaTlTransport(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AccessPointRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessPointRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessPointRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhonePrefixRules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhonePrefixRules = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ips = append(m.Ips, &IpPort{})
			if err := m.Ips[len(m.Ips)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAccessPointRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_accessPointRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_accessPointRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &AccessPointRule{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BadMsgNotification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadMsgNotification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadMsgNotification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadMsgId", wireType)
			}
			m.BadMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BadMsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadMsgSeqno", wireType)
			}
			m.BadMsgSeqno = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BadMsgSeqno |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewServerSalt", wireType)
			}
			m.NewServerSalt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewServerSalt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLBadMsgNotification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_bad_msg_notification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_bad_msg_notification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &BadMsgNotification{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLBadServerSalt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_bad_server_salt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_bad_server_salt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &BadMsgNotification{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DestroySessionRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestroySessionRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestroySessionRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDestroySessionOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_destroy_session_ok: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_destroy_session_ok: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &DestroySessionRes{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDestroySessionNone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_destroy_session_none: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_destroy_session_none: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &DestroySessionRes{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FutureSalt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FutureSalt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FutureSalt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidSince", wireType)
			}
			m.ValidSince = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidSince |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			m.ValidUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidUntil |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			m.Salt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Salt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLFutureSalt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_future_salt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_future_salt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &FutureSalt{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FutureSalts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FutureSalts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FutureSalts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMsgId", wireType)
			}
			m.ReqMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Now", wireType)
			}
			m.Now = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Now |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salts = append(m.Salts, &TLFutureSalt{})
			if err := m.Salts[len(m.Salts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLFutureSalts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_future_salts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_future_salts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &FutureSalts{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpWait) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpWait: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpWait: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDelay", wireType)
			}
			m.MaxDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDelay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitAfter", wireType)
			}
			m.WaitAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitAfter |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWait", wireType)
			}
			m.MaxWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxWait |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLHttpWait) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_http_wait: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_http_wait: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &HttpWait{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			m.Ipv4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ipv4 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = append(m.Secret[:0], dAtA[iNdEx:postIndex]...)
			if m.Secret == nil {
				m.Secret = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLIpPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_ipPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_ipPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &IpPort{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLIpPortSecret) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_ipPortSecret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_ipPortSecret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &IpPort{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDetailedInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDetailedInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDetailedInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnswerMsgId", wireType)
			}
			m.AnswerMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnswerMsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgDetailedInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msg_detailed_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msg_detailed_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgDetailedInfo{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgNewDetailedInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msg_new_detailed_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msg_new_detailed_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgDetailedInfo{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResendReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResendReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResendReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MsgIds) == 0 {
					m.MsgIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchemaTlTransport
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgResendReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msg_resend_req: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msg_resend_req: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgResendReq{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgsAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgsAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgsAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MsgIds) == 0 {
					m.MsgIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchemaTlTransport
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgsAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msgs_ack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msgs_ack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgsAck{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgsAllInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgsAllInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgsAllInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MsgIds) == 0 {
					m.MsgIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchemaTlTransport
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgsAllInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msgs_all_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msgs_all_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgsAllInfo{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgsStateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgsStateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgsStateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMsgId", wireType)
			}
			m.ReqMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgsStateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msgs_state_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msgs_state_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgsStateInfo{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgsStateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgsStateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgsStateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MsgIds) == 0 {
					m.MsgIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchemaTlTransport
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgsStateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msgs_state_req: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msgs_state_req: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgsStateReq{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstMsgId", wireType)
			}
			m.FirstMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstMsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			m.UniqueId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UniqueId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSalt", wireType)
			}
			m.ServerSalt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerSalt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLNewSessionCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_new_session_created: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_new_session_created: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &NewSession{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingId", wireType)
			}
			m.PingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PingId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLPong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_pong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_pong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Pong{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpcDropAnswer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcDropAnswer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcDropAnswer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNo", wireType)
			}
			m.SeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLRpcAnswerUnknown) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_rpc_answer_unknown: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_rpc_answer_unknown: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &RpcDropAnswer{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLRpcAnswerDroppedRunning) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_rpc_answer_dropped_running: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_rpc_answer_dropped_running: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &RpcDropAnswer{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLRpcAnswerDropped) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_rpc_answer_dropped: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_rpc_answer_dropped: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &RpcDropAnswer{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpcError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLRpcError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_rpc_error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_rpc_error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &RpcError{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Help_ConfigSimple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: help_ConfigSimple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: help_ConfigSimple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= TLCmd(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			m.Expires = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expires |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPortList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPortList = append(m.IpPortList, &IpPort{})
			if err := m.IpPortList[len(m.IpPortList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &AccessPointRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLHelpConfigSimple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_help_configSimple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_help_configSimple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Help_ConfigSimple{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSchemaTlTransport(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSchemaTlTransport
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSchemaTlTransport
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSchemaTlTransport
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSchemaTlTransport        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSchemaTlTransport          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSchemaTlTransport = fmt.Errorf("proto: unexpected end of group")
)

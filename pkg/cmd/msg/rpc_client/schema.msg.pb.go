// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: schema.msg.proto

package rpc_client

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	mtproto "novachat_engine/mtproto"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

/////  Msg
type SendMessageData struct {
	RandomId         int64            `protobuf:"varint,1,opt,name=random_id,json=randomId,proto3" json:"random_id,omitempty"`
	Message          *mtproto.Message `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	ReplyToMessageId int32            `protobuf:"varint,3,opt,name=reply_to_message_id,json=replyToMessageId,proto3" json:"reply_to_message_id,omitempty"`
}

func (m *SendMessageData) Reset()         { *m = SendMessageData{} }
func (m *SendMessageData) String() string { return proto.CompactTextString(m) }
func (*SendMessageData) ProtoMessage()    {}
func (*SendMessageData) Descriptor() ([]byte, []int) {
	return fileDescriptor_28e0be1dcaf1cd95, []int{0}
}
func (m *SendMessageData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendMessageData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendMessageData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendMessageData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendMessageData.Merge(m, src)
}
func (m *SendMessageData) XXX_Size() int {
	return m.Size()
}
func (m *SendMessageData) XXX_DiscardUnknown() {
	xxx_messageInfo_SendMessageData.DiscardUnknown(m)
}

var xxx_messageInfo_SendMessageData proto.InternalMessageInfo

func (m *SendMessageData) GetRandomId() int64 {
	if m != nil {
		return m.RandomId
	}
	return 0
}

func (m *SendMessageData) GetMessage() *mtproto.Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *SendMessageData) GetReplyToMessageId() int32 {
	if m != nil {
		return m.ReplyToMessageId
	}
	return 0
}

type SendMessages struct {
	AuthKeyId           int64              `protobuf:"varint,1,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	FromUserId          int64              `protobuf:"varint,2,opt,name=from_user_id,json=fromUserId,proto3" json:"from_user_id,omitempty"`
	PeerId              int64              `protobuf:"varint,3,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	PeerType            int32              `protobuf:"varint,4,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	DataList            []*SendMessageData `protobuf:"bytes,5,rep,name=data_list,json=dataList,proto3" json:"data_list,omitempty"`
	ClearDraft          bool               `protobuf:"varint,6,opt,name=clear_draft,json=clearDraft,proto3" json:"clear_draft,omitempty"`
	GlobalMessageIdList []int64            `protobuf:"varint,7,rep,packed,name=global_message_id_list,json=globalMessageIdList,proto3" json:"global_message_id_list,omitempty"`
}

func (m *SendMessages) Reset()         { *m = SendMessages{} }
func (m *SendMessages) String() string { return proto.CompactTextString(m) }
func (*SendMessages) ProtoMessage()    {}
func (*SendMessages) Descriptor() ([]byte, []int) {
	return fileDescriptor_28e0be1dcaf1cd95, []int{1}
}
func (m *SendMessages) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendMessages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendMessages.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendMessages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendMessages.Merge(m, src)
}
func (m *SendMessages) XXX_Size() int {
	return m.Size()
}
func (m *SendMessages) XXX_DiscardUnknown() {
	xxx_messageInfo_SendMessages.DiscardUnknown(m)
}

var xxx_messageInfo_SendMessages proto.InternalMessageInfo

func (m *SendMessages) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *SendMessages) GetFromUserId() int64 {
	if m != nil {
		return m.FromUserId
	}
	return 0
}

func (m *SendMessages) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *SendMessages) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *SendMessages) GetDataList() []*SendMessageData {
	if m != nil {
		return m.DataList
	}
	return nil
}

func (m *SendMessages) GetClearDraft() bool {
	if m != nil {
		return m.ClearDraft
	}
	return false
}

func (m *SendMessages) GetGlobalMessageIdList() []int64 {
	if m != nil {
		return m.GlobalMessageIdList
	}
	return nil
}

type EditMessage struct {
	AuthKeyId    int64                    `protobuf:"varint,1,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	FromUserId   int64                    `protobuf:"varint,2,opt,name=from_user_id,json=fromUserId,proto3" json:"from_user_id,omitempty"`
	PeerId       int64                    `protobuf:"varint,3,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	PeerType     int32                    `protobuf:"varint,4,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	MessageId    int32                    `protobuf:"varint,5,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	Message      string                   `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
	Media        *mtproto.MessageMedia    `protobuf:"bytes,7,opt,name=media,proto3" json:"media,omitempty"`
	Entities     []*mtproto.MessageEntity `protobuf:"bytes,8,rep,name=entities,proto3" json:"entities,omitempty"`
	ReplyMarkup  *mtproto.ReplyMarkup     `protobuf:"bytes,9,opt,name=reply_markup,json=replyMarkup,proto3" json:"reply_markup,omitempty"`
	ScheduleData int32                    `protobuf:"varint,10,opt,name=schedule_data,json=scheduleData,proto3" json:"schedule_data,omitempty"`
}

func (m *EditMessage) Reset()         { *m = EditMessage{} }
func (m *EditMessage) String() string { return proto.CompactTextString(m) }
func (*EditMessage) ProtoMessage()    {}
func (*EditMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_28e0be1dcaf1cd95, []int{2}
}
func (m *EditMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EditMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EditMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EditMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EditMessage.Merge(m, src)
}
func (m *EditMessage) XXX_Size() int {
	return m.Size()
}
func (m *EditMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_EditMessage.DiscardUnknown(m)
}

var xxx_messageInfo_EditMessage proto.InternalMessageInfo

func (m *EditMessage) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *EditMessage) GetFromUserId() int64 {
	if m != nil {
		return m.FromUserId
	}
	return 0
}

func (m *EditMessage) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *EditMessage) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *EditMessage) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *EditMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *EditMessage) GetMedia() *mtproto.MessageMedia {
	if m != nil {
		return m.Media
	}
	return nil
}

func (m *EditMessage) GetEntities() []*mtproto.MessageEntity {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *EditMessage) GetReplyMarkup() *mtproto.ReplyMarkup {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *EditMessage) GetScheduleData() int32 {
	if m != nil {
		return m.ScheduleData
	}
	return 0
}

type RevokeMessages struct {
	UserId              int64   `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	PeerId              int64   `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	PeerType            int32   `protobuf:"varint,3,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	GlobalMessageIdList []int64 `protobuf:"varint,4,rep,packed,name=global_message_id_list,json=globalMessageIdList,proto3" json:"global_message_id_list,omitempty"`
	Range               bool    `protobuf:"varint,5,opt,name=range,proto3" json:"range,omitempty"`
	ChannelPts          int32   `protobuf:"varint,6,opt,name=channel_pts,json=channelPts,proto3" json:"channel_pts,omitempty"`
	All                 bool    `protobuf:"varint,7,opt,name=all,proto3" json:"all,omitempty"`
}

func (m *RevokeMessages) Reset()         { *m = RevokeMessages{} }
func (m *RevokeMessages) String() string { return proto.CompactTextString(m) }
func (*RevokeMessages) ProtoMessage()    {}
func (*RevokeMessages) Descriptor() ([]byte, []int) {
	return fileDescriptor_28e0be1dcaf1cd95, []int{3}
}
func (m *RevokeMessages) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RevokeMessages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RevokeMessages.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RevokeMessages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevokeMessages.Merge(m, src)
}
func (m *RevokeMessages) XXX_Size() int {
	return m.Size()
}
func (m *RevokeMessages) XXX_DiscardUnknown() {
	xxx_messageInfo_RevokeMessages.DiscardUnknown(m)
}

var xxx_messageInfo_RevokeMessages proto.InternalMessageInfo

func (m *RevokeMessages) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *RevokeMessages) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *RevokeMessages) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *RevokeMessages) GetGlobalMessageIdList() []int64 {
	if m != nil {
		return m.GlobalMessageIdList
	}
	return nil
}

func (m *RevokeMessages) GetRange() bool {
	if m != nil {
		return m.Range
	}
	return false
}

func (m *RevokeMessages) GetChannelPts() int32 {
	if m != nil {
		return m.ChannelPts
	}
	return 0
}

func (m *RevokeMessages) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

type ReadHistory struct {
	UserId          int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	PeerId          int64 `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	PeerType        int32 `protobuf:"varint,3,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	GlobalMessageId int64 `protobuf:"varint,4,opt,name=global_message_id,json=globalMessageId,proto3" json:"global_message_id,omitempty"`
}

func (m *ReadHistory) Reset()         { *m = ReadHistory{} }
func (m *ReadHistory) String() string { return proto.CompactTextString(m) }
func (*ReadHistory) ProtoMessage()    {}
func (*ReadHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_28e0be1dcaf1cd95, []int{4}
}
func (m *ReadHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadHistory.Merge(m, src)
}
func (m *ReadHistory) XXX_Size() int {
	return m.Size()
}
func (m *ReadHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadHistory.DiscardUnknown(m)
}

var xxx_messageInfo_ReadHistory proto.InternalMessageInfo

func (m *ReadHistory) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReadHistory) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *ReadHistory) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *ReadHistory) GetGlobalMessageId() int64 {
	if m != nil {
		return m.GlobalMessageId
	}
	return 0
}

type PinnedMessage struct {
	UserId          int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	PeerId          int64 `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	PeerType        int32 `protobuf:"varint,3,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	MessageId       int32 `protobuf:"varint,4,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	Unpin           bool  `protobuf:"varint,5,opt,name=unpin,proto3" json:"unpin,omitempty"`
	OneSide         bool  `protobuf:"varint,6,opt,name=one_side,json=oneSide,proto3" json:"one_side,omitempty"`
	AuthKeyId       int64 `protobuf:"varint,7,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	GlobalMessageId int64 `protobuf:"varint,8,opt,name=global_message_id,json=globalMessageId,proto3" json:"global_message_id,omitempty"`
}

func (m *PinnedMessage) Reset()         { *m = PinnedMessage{} }
func (m *PinnedMessage) String() string { return proto.CompactTextString(m) }
func (*PinnedMessage) ProtoMessage()    {}
func (*PinnedMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_28e0be1dcaf1cd95, []int{5}
}
func (m *PinnedMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PinnedMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PinnedMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PinnedMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PinnedMessage.Merge(m, src)
}
func (m *PinnedMessage) XXX_Size() int {
	return m.Size()
}
func (m *PinnedMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_PinnedMessage.DiscardUnknown(m)
}

var xxx_messageInfo_PinnedMessage proto.InternalMessageInfo

func (m *PinnedMessage) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *PinnedMessage) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *PinnedMessage) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *PinnedMessage) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *PinnedMessage) GetUnpin() bool {
	if m != nil {
		return m.Unpin
	}
	return false
}

func (m *PinnedMessage) GetOneSide() bool {
	if m != nil {
		return m.OneSide
	}
	return false
}

func (m *PinnedMessage) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *PinnedMessage) GetGlobalMessageId() int64 {
	if m != nil {
		return m.GlobalMessageId
	}
	return 0
}

func init() {
	proto.RegisterType((*SendMessageData)(nil), "rpc_client.SendMessageData")
	proto.RegisterType((*SendMessages)(nil), "rpc_client.SendMessages")
	proto.RegisterType((*EditMessage)(nil), "rpc_client.EditMessage")
	proto.RegisterType((*RevokeMessages)(nil), "rpc_client.RevokeMessages")
	proto.RegisterType((*ReadHistory)(nil), "rpc_client.ReadHistory")
	proto.RegisterType((*PinnedMessage)(nil), "rpc_client.PinnedMessage")
}

func init() { proto.RegisterFile("schema.msg.proto", fileDescriptor_28e0be1dcaf1cd95) }

var fileDescriptor_28e0be1dcaf1cd95 = []byte{
	// 702 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x55, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0xad, 0xe3, 0x26, 0x71, 0x6e, 0xd2, 0xaf, 0xf9, 0xa6, 0xf9, 0x5a, 0x7f, 0x2d, 0x24, 0x51,
	0xd9, 0x44, 0x45, 0x75, 0xa5, 0x76, 0x01, 0x62, 0x89, 0x5a, 0x89, 0x08, 0x2a, 0x55, 0xd3, 0xb2,
	0x61, 0x63, 0x4d, 0x32, 0xd3, 0xc4, 0xaa, 0x3d, 0x63, 0x79, 0xc6, 0x48, 0x7e, 0x03, 0x24, 0x36,
	0xac, 0x80, 0x2d, 0x15, 0x0f, 0xc3, 0xb2, 0x8f, 0x00, 0xdd, 0xb2, 0xe1, 0x11, 0xd0, 0x8c, 0xf3,
	0x87, 0x4b, 0x25, 0x16, 0x95, 0xd8, 0xf9, 0xde, 0x73, 0x3c, 0xbe, 0xf7, 0x9c, 0x33, 0x09, 0x34,
	0xe5, 0x70, 0xcc, 0x22, 0xe2, 0x45, 0x72, 0xe4, 0xc5, 0x89, 0x50, 0x02, 0x41, 0x12, 0x0f, 0xfd,
	0x61, 0x18, 0x30, 0xae, 0x36, 0x77, 0x47, 0x81, 0x1a, 0xa7, 0x03, 0x6f, 0x28, 0xa2, 0xbd, 0x91,
	0x18, 0x89, 0x3d, 0x43, 0x19, 0xa4, 0xe7, 0xa6, 0x32, 0x85, 0x79, 0xca, 0x5f, 0xdd, 0x6c, 0x4d,
	0x0e, 0x53, 0xa1, 0x27, 0x33, 0x3e, 0xcc, 0xbb, 0xdb, 0x1f, 0x2c, 0x58, 0x3d, 0x65, 0x9c, 0x1e,
	0x33, 0x29, 0xc9, 0x88, 0x1d, 0x12, 0x45, 0xd0, 0x16, 0xd4, 0x12, 0xc2, 0xa9, 0x88, 0xfc, 0x80,
	0xba, 0x56, 0xd7, 0xea, 0xd9, 0xd8, 0xc9, 0x1b, 0x7d, 0x8a, 0x76, 0xa0, 0x1a, 0xe5, 0x5c, 0xb7,
	0xd4, 0xb5, 0x7a, 0xf5, 0xfd, 0xa6, 0x17, 0x29, 0x73, 0x96, 0x37, 0x39, 0x03, 0x4f, 0x09, 0x68,
	0x17, 0xd6, 0x12, 0x16, 0x87, 0x99, 0xaf, 0x84, 0x3f, 0xe9, 0xe9, 0x23, 0xed, 0xae, 0xd5, 0x2b,
	0xe3, 0xa6, 0x81, 0xce, 0xc4, 0xe4, 0xad, 0x3e, 0x7d, 0xd2, 0xb8, 0xfa, 0xd4, 0x59, 0x7a, 0x77,
	0xd9, 0x59, 0xfa, 0x78, 0xd9, 0x59, 0xda, 0xfe, 0x5c, 0x82, 0xc6, 0xc2, 0x64, 0x12, 0xb5, 0xa1,
	0x4e, 0x52, 0x35, 0xf6, 0x2f, 0x58, 0x36, 0x1f, 0xac, 0xa6, 0x5b, 0xcf, 0x59, 0xd6, 0xa7, 0xa8,
	0x0b, 0x8d, 0xf3, 0x44, 0x44, 0x7e, 0x2a, 0x59, 0xa2, 0x09, 0x25, 0x43, 0x00, 0xdd, 0x7b, 0x29,
	0x59, 0xd2, 0xa7, 0x68, 0x03, 0xaa, 0x31, 0xcb, 0x41, 0xdb, 0x80, 0x15, 0x5d, 0xf6, 0xa9, 0xde,
	0xd8, 0x00, 0x2a, 0x8b, 0x99, 0xbb, 0x6c, 0xc6, 0x73, 0x74, 0xe3, 0x2c, 0x8b, 0x19, 0x7a, 0x0c,
	0x35, 0x4a, 0x14, 0xf1, 0xc3, 0x40, 0x2a, 0xb7, 0xdc, 0xb5, 0x7b, 0xf5, 0xfd, 0x2d, 0x6f, 0xee,
	0x83, 0x57, 0x90, 0x0f, 0x3b, 0x9a, 0xfd, 0x22, 0x90, 0x0a, 0x75, 0xa0, 0x3e, 0x0c, 0x19, 0x49,
	0x7c, 0x9a, 0x90, 0x73, 0xe5, 0x56, 0xba, 0x56, 0xcf, 0xc1, 0x60, 0x5a, 0x87, 0xba, 0x83, 0x0e,
	0x60, 0x7d, 0x14, 0x8a, 0x01, 0x09, 0x17, 0xe4, 0xc9, 0xbf, 0x53, 0xed, 0xda, 0x3d, 0x1b, 0xaf,
	0xe5, 0xe8, 0x4c, 0x22, 0x7d, 0x6a, 0x41, 0xa6, 0xb7, 0x36, 0xd4, 0x8f, 0x68, 0xa0, 0x26, 0x9c,
	0xbf, 0xa6, 0xd2, 0x7d, 0x80, 0x05, 0x8b, 0xcb, 0x06, 0xad, 0x45, 0xd3, 0xc1, 0x91, 0x3b, 0x8f,
	0x8d, 0x96, 0xa1, 0x36, 0x0f, 0xc9, 0x43, 0x28, 0x47, 0x8c, 0x06, 0xc4, 0xad, 0x9a, 0x38, 0xfd,
	0x57, 0x8c, 0xd3, 0xb1, 0x06, 0x71, 0xce, 0x41, 0xfb, 0xe0, 0x30, 0xae, 0x02, 0x15, 0x30, 0xe9,
	0x3a, 0xc6, 0x8a, 0xf5, 0x22, 0xff, 0x48, 0xe3, 0x19, 0x9e, 0xf1, 0xd0, 0x23, 0x68, 0xe4, 0x29,
	0x8c, 0x48, 0x72, 0x91, 0xc6, 0x6e, 0xcd, 0x7c, 0xa7, 0x35, 0x7b, 0x0f, 0x6b, 0xf0, 0xd8, 0x60,
	0xb8, 0x9e, 0xcc, 0x0b, 0xf4, 0x00, 0x56, 0xf4, 0x9d, 0xa1, 0x69, 0xc8, 0x7c, 0xed, 0xa9, 0x0b,
	0x66, 0xab, 0xc6, 0xb4, 0xa9, 0xdd, 0x2e, 0xb8, 0xf1, 0xdd, 0x82, 0x7f, 0x30, 0x7b, 0x2d, 0x2e,
	0xd8, 0x2c, 0xb6, 0x1b, 0x50, 0x9d, 0x6a, 0x9d, 0x9b, 0x51, 0x49, 0x6f, 0xe8, 0x5c, 0xba, 0x5d,
	0x67, 0xbb, 0xa0, 0xf3, 0xed, 0x91, 0x59, 0xbe, 0x35, 0x32, 0xa8, 0x05, 0xe5, 0x84, 0xf0, 0x11,
	0x33, 0xbe, 0x38, 0x38, 0x2f, 0x4c, 0x3c, 0xc7, 0x84, 0x73, 0x16, 0xfa, 0xb1, 0x92, 0xc6, 0x97,
	0x32, 0x86, 0x49, 0xeb, 0x44, 0x49, 0xd4, 0x04, 0x9b, 0x84, 0xa1, 0x31, 0xc6, 0xc1, 0xfa, 0xb1,
	0xb0, 0xed, 0x7b, 0x0b, 0xea, 0x98, 0x11, 0xfa, 0x2c, 0x90, 0x4a, 0x24, 0xd9, 0x5d, 0xaf, 0xba,
	0x03, 0xff, 0xde, 0x58, 0xd5, 0xe4, 0xce, 0xc6, 0xab, 0x85, 0x2d, 0x0b, 0x83, 0xbd, 0x29, 0xc1,
	0xca, 0x49, 0xc0, 0x39, 0x9b, 0x5e, 0xcc, 0xbb, 0x1e, 0xed, 0xd7, 0xb4, 0x2f, 0x17, 0xd3, 0xde,
	0x82, 0x72, 0xca, 0xe3, 0x80, 0x4f, 0xf5, 0x36, 0x05, 0xfa, 0x1f, 0x1c, 0xc1, 0x99, 0x2f, 0x03,
	0xca, 0x26, 0xbf, 0x05, 0x55, 0xc1, 0xd9, 0x69, 0x40, 0x6f, 0xdc, 0xda, 0x6a, 0xf1, 0xd6, 0xfe,
	0x56, 0x0a, 0xe7, 0x0f, 0xa4, 0x78, 0x7a, 0xef, 0xc7, 0xb7, 0xb6, 0xf5, 0xe5, 0xba, 0x6d, 0x5d,
	0x5d, 0xb7, 0xad, 0xaf, 0xd7, 0x6d, 0xeb, 0xd5, 0xc2, 0x7f, 0xc8, 0xa0, 0x62, 0xae, 0xc0, 0xc1,
	0xcf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x67, 0x35, 0x1c, 0x6d, 0x6a, 0x06, 0x00, 0x00,
}

func (this *SendMessageData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&rpc_client.SendMessageData{")
	s = append(s, "RandomId: "+fmt.Sprintf("%#v", this.RandomId)+",\n")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	s = append(s, "ReplyToMessageId: "+fmt.Sprintf("%#v", this.ReplyToMessageId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendMessages) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&rpc_client.SendMessages{")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "FromUserId: "+fmt.Sprintf("%#v", this.FromUserId)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "PeerType: "+fmt.Sprintf("%#v", this.PeerType)+",\n")
	if this.DataList != nil {
		s = append(s, "DataList: "+fmt.Sprintf("%#v", this.DataList)+",\n")
	}
	s = append(s, "ClearDraft: "+fmt.Sprintf("%#v", this.ClearDraft)+",\n")
	s = append(s, "GlobalMessageIdList: "+fmt.Sprintf("%#v", this.GlobalMessageIdList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EditMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&rpc_client.EditMessage{")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "FromUserId: "+fmt.Sprintf("%#v", this.FromUserId)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "PeerType: "+fmt.Sprintf("%#v", this.PeerType)+",\n")
	s = append(s, "MessageId: "+fmt.Sprintf("%#v", this.MessageId)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	if this.Media != nil {
		s = append(s, "Media: "+fmt.Sprintf("%#v", this.Media)+",\n")
	}
	if this.Entities != nil {
		s = append(s, "Entities: "+fmt.Sprintf("%#v", this.Entities)+",\n")
	}
	if this.ReplyMarkup != nil {
		s = append(s, "ReplyMarkup: "+fmt.Sprintf("%#v", this.ReplyMarkup)+",\n")
	}
	s = append(s, "ScheduleData: "+fmt.Sprintf("%#v", this.ScheduleData)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RevokeMessages) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&rpc_client.RevokeMessages{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "PeerType: "+fmt.Sprintf("%#v", this.PeerType)+",\n")
	s = append(s, "GlobalMessageIdList: "+fmt.Sprintf("%#v", this.GlobalMessageIdList)+",\n")
	s = append(s, "Range: "+fmt.Sprintf("%#v", this.Range)+",\n")
	s = append(s, "ChannelPts: "+fmt.Sprintf("%#v", this.ChannelPts)+",\n")
	s = append(s, "All: "+fmt.Sprintf("%#v", this.All)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadHistory) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&rpc_client.ReadHistory{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "PeerType: "+fmt.Sprintf("%#v", this.PeerType)+",\n")
	s = append(s, "GlobalMessageId: "+fmt.Sprintf("%#v", this.GlobalMessageId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PinnedMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&rpc_client.PinnedMessage{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "PeerType: "+fmt.Sprintf("%#v", this.PeerType)+",\n")
	s = append(s, "MessageId: "+fmt.Sprintf("%#v", this.MessageId)+",\n")
	s = append(s, "Unpin: "+fmt.Sprintf("%#v", this.Unpin)+",\n")
	s = append(s, "OneSide: "+fmt.Sprintf("%#v", this.OneSide)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "GlobalMessageId: "+fmt.Sprintf("%#v", this.GlobalMessageId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringSchemaMsg(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *SendMessageData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMessageData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendMessageData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReplyToMessageId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.ReplyToMessageId))
		i--
		dAtA[i] = 0x18
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RandomId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.RandomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SendMessages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMessages) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendMessages) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GlobalMessageIdList) > 0 {
		dAtA3 := make([]byte, len(m.GlobalMessageIdList)*10)
		var j2 int
		for _, num1 := range m.GlobalMessageIdList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintSchemaMsg(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x3a
	}
	if m.ClearDraft {
		i--
		if m.ClearDraft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.DataList) > 0 {
		for iNdEx := len(m.DataList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchemaMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PeerType != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x20
	}
	if m.PeerId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x18
	}
	if m.FromUserId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.FromUserId))
		i--
		dAtA[i] = 0x10
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EditMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EditMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ScheduleData != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.ScheduleData))
		i--
		dAtA[i] = 0x50
	}
	if m.ReplyMarkup != nil {
		{
			size, err := m.ReplyMarkup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchemaMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Media != nil {
		{
			size, err := m.Media.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintSchemaMsg(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x32
	}
	if m.MessageId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.MessageId))
		i--
		dAtA[i] = 0x28
	}
	if m.PeerType != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x20
	}
	if m.PeerId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x18
	}
	if m.FromUserId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.FromUserId))
		i--
		dAtA[i] = 0x10
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RevokeMessages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RevokeMessages) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RevokeMessages) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ChannelPts != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.ChannelPts))
		i--
		dAtA[i] = 0x30
	}
	if m.Range {
		i--
		if m.Range {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.GlobalMessageIdList) > 0 {
		dAtA7 := make([]byte, len(m.GlobalMessageIdList)*10)
		var j6 int
		for _, num1 := range m.GlobalMessageIdList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintSchemaMsg(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x22
	}
	if m.PeerType != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReadHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GlobalMessageId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.GlobalMessageId))
		i--
		dAtA[i] = 0x20
	}
	if m.PeerType != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PinnedMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PinnedMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PinnedMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GlobalMessageId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.GlobalMessageId))
		i--
		dAtA[i] = 0x40
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x38
	}
	if m.OneSide {
		i--
		if m.OneSide {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Unpin {
		i--
		if m.Unpin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.MessageId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.MessageId))
		i--
		dAtA[i] = 0x20
	}
	if m.PeerType != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintSchemaMsg(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSchemaMsg(dAtA []byte, offset int, v uint64) int {
	offset -= sovSchemaMsg(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SendMessageData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RandomId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.RandomId))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovSchemaMsg(uint64(l))
	}
	if m.ReplyToMessageId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.ReplyToMessageId))
	}
	return n
}

func (m *SendMessages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.AuthKeyId))
	}
	if m.FromUserId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.FromUserId))
	}
	if m.PeerId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.PeerId))
	}
	if m.PeerType != 0 {
		n += 1 + sovSchemaMsg(uint64(m.PeerType))
	}
	if len(m.DataList) > 0 {
		for _, e := range m.DataList {
			l = e.Size()
			n += 1 + l + sovSchemaMsg(uint64(l))
		}
	}
	if m.ClearDraft {
		n += 2
	}
	if len(m.GlobalMessageIdList) > 0 {
		l = 0
		for _, e := range m.GlobalMessageIdList {
			l += sovSchemaMsg(uint64(e))
		}
		n += 1 + sovSchemaMsg(uint64(l)) + l
	}
	return n
}

func (m *EditMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.AuthKeyId))
	}
	if m.FromUserId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.FromUserId))
	}
	if m.PeerId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.PeerId))
	}
	if m.PeerType != 0 {
		n += 1 + sovSchemaMsg(uint64(m.PeerType))
	}
	if m.MessageId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.MessageId))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovSchemaMsg(uint64(l))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovSchemaMsg(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovSchemaMsg(uint64(l))
		}
	}
	if m.ReplyMarkup != nil {
		l = m.ReplyMarkup.Size()
		n += 1 + l + sovSchemaMsg(uint64(l))
	}
	if m.ScheduleData != 0 {
		n += 1 + sovSchemaMsg(uint64(m.ScheduleData))
	}
	return n
}

func (m *RevokeMessages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.UserId))
	}
	if m.PeerId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.PeerId))
	}
	if m.PeerType != 0 {
		n += 1 + sovSchemaMsg(uint64(m.PeerType))
	}
	if len(m.GlobalMessageIdList) > 0 {
		l = 0
		for _, e := range m.GlobalMessageIdList {
			l += sovSchemaMsg(uint64(e))
		}
		n += 1 + sovSchemaMsg(uint64(l)) + l
	}
	if m.Range {
		n += 2
	}
	if m.ChannelPts != 0 {
		n += 1 + sovSchemaMsg(uint64(m.ChannelPts))
	}
	if m.All {
		n += 2
	}
	return n
}

func (m *ReadHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.UserId))
	}
	if m.PeerId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.PeerId))
	}
	if m.PeerType != 0 {
		n += 1 + sovSchemaMsg(uint64(m.PeerType))
	}
	if m.GlobalMessageId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.GlobalMessageId))
	}
	return n
}

func (m *PinnedMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.UserId))
	}
	if m.PeerId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.PeerId))
	}
	if m.PeerType != 0 {
		n += 1 + sovSchemaMsg(uint64(m.PeerType))
	}
	if m.MessageId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.MessageId))
	}
	if m.Unpin {
		n += 2
	}
	if m.OneSide {
		n += 2
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.AuthKeyId))
	}
	if m.GlobalMessageId != 0 {
		n += 1 + sovSchemaMsg(uint64(m.GlobalMessageId))
	}
	return n
}

func sovSchemaMsg(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSchemaMsg(x uint64) (n int) {
	return sovSchemaMsg(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SendMessageData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendMessageData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendMessageData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomId", wireType)
			}
			m.RandomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &mtproto.Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMessageId", wireType)
			}
			m.ReplyToMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMessageId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMessages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendMessages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendMessages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUserId", wireType)
			}
			m.FromUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataList = append(m.DataList, &SendMessageData{})
			if err := m.DataList[len(m.DataList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearDraft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClearDraft = bool(v != 0)
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GlobalMessageIdList = append(m.GlobalMessageIdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSchemaMsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSchemaMsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GlobalMessageIdList) == 0 {
					m.GlobalMessageIdList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchemaMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GlobalMessageIdList = append(m.GlobalMessageIdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalMessageIdList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EditMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EditMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUserId", wireType)
			}
			m.FromUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &mtproto.MessageMedia{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &mtproto.MessageEntity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = &mtproto.ReplyMarkup{}
			}
			if err := m.ReplyMarkup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleData", wireType)
			}
			m.ScheduleData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScheduleData |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevokeMessages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevokeMessages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevokeMessages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GlobalMessageIdList = append(m.GlobalMessageIdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSchemaMsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSchemaMsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GlobalMessageIdList) == 0 {
					m.GlobalMessageIdList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchemaMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GlobalMessageIdList = append(m.GlobalMessageIdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalMessageIdList", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Range = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelPts", wireType)
			}
			m.ChannelPts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelPts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalMessageId", wireType)
			}
			m.GlobalMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalMessageId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PinnedMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PinnedMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PinnedMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unpin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unpin = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneSide", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneSide = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalMessageId", wireType)
			}
			m.GlobalMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalMessageId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSchemaMsg(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSchemaMsg
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchemaMsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSchemaMsg
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSchemaMsg
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSchemaMsg
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSchemaMsg        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSchemaMsg          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSchemaMsg = fmt.Errorf("proto: unexpected end of group")
)

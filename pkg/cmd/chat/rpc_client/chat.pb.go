// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: chat.proto

package rpc_client

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	rpc_client "novachat_engine/pkg/cmd/msg/rpc_client"
	chat "novachat_engine/service/data/chat"
	fs "novachat_engine/service/data/fs"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Chat struct {
	ChatData        *chat.Chat              `protobuf:"bytes,1,opt,name=chat_data,json=chatData,proto3" json:"chat_data,omitempty"`
	ParticipantList []*chat.ChatParticipant `protobuf:"bytes,2,rep,name=participant_list,json=participantList,proto3" json:"participant_list,omitempty"`
}

func (m *Chat) Reset()         { *m = Chat{} }
func (m *Chat) String() string { return proto.CompactTextString(m) }
func (*Chat) ProtoMessage()    {}
func (*Chat) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{0}
}
func (m *Chat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Chat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Chat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Chat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chat.Merge(m, src)
}
func (m *Chat) XXX_Size() int {
	return m.Size()
}
func (m *Chat) XXX_DiscardUnknown() {
	xxx_messageInfo_Chat.DiscardUnknown(m)
}

var xxx_messageInfo_Chat proto.InternalMessageInfo

func (m *Chat) GetChatData() *chat.Chat {
	if m != nil {
		return m.ChatData
	}
	return nil
}

func (m *Chat) GetParticipantList() []*chat.ChatParticipant {
	if m != nil {
		return m.ParticipantList
	}
	return nil
}

type ChatList struct {
	Values []*Chat `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
}

func (m *ChatList) Reset()         { *m = ChatList{} }
func (m *ChatList) String() string { return proto.CompactTextString(m) }
func (*ChatList) ProtoMessage()    {}
func (*ChatList) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{1}
}
func (m *ChatList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatList.Merge(m, src)
}
func (m *ChatList) XXX_Size() int {
	return m.Size()
}
func (m *ChatList) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatList.DiscardUnknown(m)
}

var xxx_messageInfo_ChatList proto.InternalMessageInfo

func (m *ChatList) GetValues() []*Chat {
	if m != nil {
		return m.Values
	}
	return nil
}

type GeoPoint struct {
	Lat     float64 `protobuf:"fixed64,1,opt,name=lat,proto3" json:"lat,omitempty"`
	Long    float64 `protobuf:"fixed64,2,opt,name=long,proto3" json:"long,omitempty"`
	Address string  `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *GeoPoint) Reset()         { *m = GeoPoint{} }
func (m *GeoPoint) String() string { return proto.CompactTextString(m) }
func (*GeoPoint) ProtoMessage()    {}
func (*GeoPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{2}
}
func (m *GeoPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeoPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeoPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeoPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoPoint.Merge(m, src)
}
func (m *GeoPoint) XXX_Size() int {
	return m.Size()
}
func (m *GeoPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoPoint.DiscardUnknown(m)
}

var xxx_messageInfo_GeoPoint proto.InternalMessageInfo

func (m *GeoPoint) GetLat() float64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *GeoPoint) GetLong() float64 {
	if m != nil {
		return m.Long
	}
	return 0
}

func (m *GeoPoint) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type CreateChat struct {
	UserId      int64     `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId   int64     `protobuf:"varint,2,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	PeerId      []int64   `protobuf:"varint,3,rep,packed,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	Title       string    `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	ChatSizeMax int32     `protobuf:"varint,5,opt,name=chat_size_max,json=chatSizeMax,proto3" json:"chat_size_max,omitempty"`
	Date        int32     `protobuf:"varint,6,opt,name=date,proto3" json:"date,omitempty"`
	GeoPoint    *GeoPoint `protobuf:"bytes,7,opt,name=geo_point,json=geoPoint,proto3" json:"geo_point,omitempty"`
	Layer       int32     `protobuf:"varint,8,opt,name=layer,proto3" json:"layer,omitempty"`
}

func (m *CreateChat) Reset()         { *m = CreateChat{} }
func (m *CreateChat) String() string { return proto.CompactTextString(m) }
func (*CreateChat) ProtoMessage()    {}
func (*CreateChat) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{3}
}
func (m *CreateChat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateChat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateChat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateChat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateChat.Merge(m, src)
}
func (m *CreateChat) XXX_Size() int {
	return m.Size()
}
func (m *CreateChat) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateChat.DiscardUnknown(m)
}

var xxx_messageInfo_CreateChat proto.InternalMessageInfo

func (m *CreateChat) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CreateChat) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *CreateChat) GetPeerId() []int64 {
	if m != nil {
		return m.PeerId
	}
	return nil
}

func (m *CreateChat) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CreateChat) GetChatSizeMax() int32 {
	if m != nil {
		return m.ChatSizeMax
	}
	return 0
}

func (m *CreateChat) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *CreateChat) GetGeoPoint() *GeoPoint {
	if m != nil {
		return m.GeoPoint
	}
	return nil
}

func (m *CreateChat) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

type FullChat struct {
	ChatId int64 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *FullChat) Reset()         { *m = FullChat{} }
func (m *FullChat) String() string { return proto.CompactTextString(m) }
func (*FullChat) ProtoMessage()    {}
func (*FullChat) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{4}
}
func (m *FullChat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FullChat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FullChat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FullChat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FullChat.Merge(m, src)
}
func (m *FullChat) XXX_Size() int {
	return m.Size()
}
func (m *FullChat) XXX_DiscardUnknown() {
	xxx_messageInfo_FullChat.DiscardUnknown(m)
}

var xxx_messageInfo_FullChat proto.InternalMessageInfo

func (m *FullChat) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

type ChatCommon struct {
	UserId int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	MaxId  int32 `protobuf:"varint,2,opt,name=max_id,json=maxId,proto3" json:"max_id,omitempty"`
	Limit  int32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *ChatCommon) Reset()         { *m = ChatCommon{} }
func (m *ChatCommon) String() string { return proto.CompactTextString(m) }
func (*ChatCommon) ProtoMessage()    {}
func (*ChatCommon) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{5}
}
func (m *ChatCommon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatCommon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatCommon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatCommon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatCommon.Merge(m, src)
}
func (m *ChatCommon) XXX_Size() int {
	return m.Size()
}
func (m *ChatCommon) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatCommon.DiscardUnknown(m)
}

var xxx_messageInfo_ChatCommon proto.InternalMessageInfo

func (m *ChatCommon) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ChatCommon) GetMaxId() int32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

func (m *ChatCommon) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type EditTitle struct {
	ChatId    int64  `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Title     string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	UserId    int64  `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId int64  `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Date      int32  `protobuf:"varint,5,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *EditTitle) Reset()         { *m = EditTitle{} }
func (m *EditTitle) String() string { return proto.CompactTextString(m) }
func (*EditTitle) ProtoMessage()    {}
func (*EditTitle) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{6}
}
func (m *EditTitle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EditTitle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EditTitle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EditTitle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EditTitle.Merge(m, src)
}
func (m *EditTitle) XXX_Size() int {
	return m.Size()
}
func (m *EditTitle) XXX_DiscardUnknown() {
	xxx_messageInfo_EditTitle.DiscardUnknown(m)
}

var xxx_messageInfo_EditTitle proto.InternalMessageInfo

func (m *EditTitle) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *EditTitle) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *EditTitle) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *EditTitle) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *EditTitle) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

type EditAbout struct {
	ChatId    int64  `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	About     string `protobuf:"bytes,2,opt,name=about,proto3" json:"about,omitempty"`
	UserId    int64  `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId int64  `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Date      int32  `protobuf:"varint,5,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *EditAbout) Reset()         { *m = EditAbout{} }
func (m *EditAbout) String() string { return proto.CompactTextString(m) }
func (*EditAbout) ProtoMessage()    {}
func (*EditAbout) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{7}
}
func (m *EditAbout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EditAbout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EditAbout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EditAbout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EditAbout.Merge(m, src)
}
func (m *EditAbout) XXX_Size() int {
	return m.Size()
}
func (m *EditAbout) XXX_DiscardUnknown() {
	xxx_messageInfo_EditAbout.DiscardUnknown(m)
}

var xxx_messageInfo_EditAbout proto.InternalMessageInfo

func (m *EditAbout) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *EditAbout) GetAbout() string {
	if m != nil {
		return m.About
	}
	return ""
}

func (m *EditAbout) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *EditAbout) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *EditAbout) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

type EditPhoto struct {
	ChatId    int64            `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Photo     *fs.PhotoProfile `protobuf:"bytes,2,opt,name=photo,proto3" json:"photo,omitempty"`
	UserId    int64            `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId int64            `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Date      int32            `protobuf:"varint,5,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *EditPhoto) Reset()         { *m = EditPhoto{} }
func (m *EditPhoto) String() string { return proto.CompactTextString(m) }
func (*EditPhoto) ProtoMessage()    {}
func (*EditPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{8}
}
func (m *EditPhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EditPhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EditPhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EditPhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EditPhoto.Merge(m, src)
}
func (m *EditPhoto) XXX_Size() int {
	return m.Size()
}
func (m *EditPhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_EditPhoto.DiscardUnknown(m)
}

var xxx_messageInfo_EditPhoto proto.InternalMessageInfo

func (m *EditPhoto) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *EditPhoto) GetPhoto() *fs.PhotoProfile {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *EditPhoto) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *EditPhoto) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *EditPhoto) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

type BannedRights struct {
	ChatId    int64 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Rights    int32 `protobuf:"varint,2,opt,name=rights,proto3" json:"rights,omitempty"`
	UserId    int64 `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId int64 `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Date      int32 `protobuf:"varint,5,opt,name=date,proto3" json:"date,omitempty"`
	UtilDate  int32 `protobuf:"varint,6,opt,name=util_date,json=utilDate,proto3" json:"util_date,omitempty"`
}

func (m *BannedRights) Reset()         { *m = BannedRights{} }
func (m *BannedRights) String() string { return proto.CompactTextString(m) }
func (*BannedRights) ProtoMessage()    {}
func (*BannedRights) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{9}
}
func (m *BannedRights) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BannedRights) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BannedRights.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BannedRights) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BannedRights.Merge(m, src)
}
func (m *BannedRights) XXX_Size() int {
	return m.Size()
}
func (m *BannedRights) XXX_DiscardUnknown() {
	xxx_messageInfo_BannedRights.DiscardUnknown(m)
}

var xxx_messageInfo_BannedRights proto.InternalMessageInfo

func (m *BannedRights) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *BannedRights) GetRights() int32 {
	if m != nil {
		return m.Rights
	}
	return 0
}

func (m *BannedRights) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *BannedRights) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *BannedRights) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *BannedRights) GetUtilDate() int32 {
	if m != nil {
		return m.UtilDate
	}
	return 0
}

type EditAdmin struct {
	ChatId    int64 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	PeerId    int64 `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	IsAdmin   bool  `protobuf:"varint,3,opt,name=is_admin,json=isAdmin,proto3" json:"is_admin,omitempty"`
	UserId    int64 `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId int64 `protobuf:"varint,5,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Date      int32 `protobuf:"varint,6,opt,name=date,proto3" json:"date,omitempty"`
	Right     int32 `protobuf:"varint,8,opt,name=right,proto3" json:"right,omitempty"`
}

func (m *EditAdmin) Reset()         { *m = EditAdmin{} }
func (m *EditAdmin) String() string { return proto.CompactTextString(m) }
func (*EditAdmin) ProtoMessage()    {}
func (*EditAdmin) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{10}
}
func (m *EditAdmin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EditAdmin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EditAdmin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EditAdmin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EditAdmin.Merge(m, src)
}
func (m *EditAdmin) XXX_Size() int {
	return m.Size()
}
func (m *EditAdmin) XXX_DiscardUnknown() {
	xxx_messageInfo_EditAdmin.DiscardUnknown(m)
}

var xxx_messageInfo_EditAdmin proto.InternalMessageInfo

func (m *EditAdmin) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *EditAdmin) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *EditAdmin) GetIsAdmin() bool {
	if m != nil {
		return m.IsAdmin
	}
	return false
}

func (m *EditAdmin) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *EditAdmin) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *EditAdmin) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *EditAdmin) GetRight() int32 {
	if m != nil {
		return m.Right
	}
	return 0
}

type ChatByName struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	UserId   int64  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *ChatByName) Reset()         { *m = ChatByName{} }
func (m *ChatByName) String() string { return proto.CompactTextString(m) }
func (*ChatByName) ProtoMessage()    {}
func (*ChatByName) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{11}
}
func (m *ChatByName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatByName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatByName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatByName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatByName.Merge(m, src)
}
func (m *ChatByName) XXX_Size() int {
	return m.Size()
}
func (m *ChatByName) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatByName.DiscardUnknown(m)
}

var xxx_messageInfo_ChatByName proto.InternalMessageInfo

func (m *ChatByName) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ChatByName) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type AddUser struct {
	UserId    int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ChatId    int64 `protobuf:"varint,2,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	PeerId    int64 `protobuf:"varint,3,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	FwdLimit  int32 `protobuf:"varint,4,opt,name=fwd_limit,json=fwdLimit,proto3" json:"fwd_limit,omitempty"`
	AuthKeyId int64 `protobuf:"varint,5,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Date      int32 `protobuf:"varint,6,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *AddUser) Reset()         { *m = AddUser{} }
func (m *AddUser) String() string { return proto.CompactTextString(m) }
func (*AddUser) ProtoMessage()    {}
func (*AddUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{12}
}
func (m *AddUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddUser.Merge(m, src)
}
func (m *AddUser) XXX_Size() int {
	return m.Size()
}
func (m *AddUser) XXX_DiscardUnknown() {
	xxx_messageInfo_AddUser.DiscardUnknown(m)
}

var xxx_messageInfo_AddUser proto.InternalMessageInfo

func (m *AddUser) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *AddUser) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *AddUser) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *AddUser) GetFwdLimit() int32 {
	if m != nil {
		return m.FwdLimit
	}
	return 0
}

func (m *AddUser) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *AddUser) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

type DeleteUser struct {
	UserId    int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ChatId    int64 `protobuf:"varint,2,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	PeerId    int64 `protobuf:"varint,3,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	AuthKeyId int64 `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Date      int32 `protobuf:"varint,5,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *DeleteUser) Reset()         { *m = DeleteUser{} }
func (m *DeleteUser) String() string { return proto.CompactTextString(m) }
func (*DeleteUser) ProtoMessage()    {}
func (*DeleteUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{13}
}
func (m *DeleteUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteUser.Merge(m, src)
}
func (m *DeleteUser) XXX_Size() int {
	return m.Size()
}
func (m *DeleteUser) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteUser.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteUser proto.InternalMessageInfo

func (m *DeleteUser) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteUser) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *DeleteUser) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *DeleteUser) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *DeleteUser) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

type SendOutboxesMessages struct {
	Message *rpc_client.SendMessages `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *SendOutboxesMessages) Reset()         { *m = SendOutboxesMessages{} }
func (m *SendOutboxesMessages) String() string { return proto.CompactTextString(m) }
func (*SendOutboxesMessages) ProtoMessage()    {}
func (*SendOutboxesMessages) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{14}
}
func (m *SendOutboxesMessages) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendOutboxesMessages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendOutboxesMessages.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendOutboxesMessages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendOutboxesMessages.Merge(m, src)
}
func (m *SendOutboxesMessages) XXX_Size() int {
	return m.Size()
}
func (m *SendOutboxesMessages) XXX_DiscardUnknown() {
	xxx_messageInfo_SendOutboxesMessages.DiscardUnknown(m)
}

var xxx_messageInfo_SendOutboxesMessages proto.InternalMessageInfo

func (m *SendOutboxesMessages) GetMessage() *rpc_client.SendMessages {
	if m != nil {
		return m.Message
	}
	return nil
}

type SendInBoxesMessages struct {
	Message *rpc_client.SendMessages `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *SendInBoxesMessages) Reset()         { *m = SendInBoxesMessages{} }
func (m *SendInBoxesMessages) String() string { return proto.CompactTextString(m) }
func (*SendInBoxesMessages) ProtoMessage()    {}
func (*SendInBoxesMessages) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{15}
}
func (m *SendInBoxesMessages) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendInBoxesMessages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendInBoxesMessages.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendInBoxesMessages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendInBoxesMessages.Merge(m, src)
}
func (m *SendInBoxesMessages) XXX_Size() int {
	return m.Size()
}
func (m *SendInBoxesMessages) XXX_DiscardUnknown() {
	xxx_messageInfo_SendInBoxesMessages.DiscardUnknown(m)
}

var xxx_messageInfo_SendInBoxesMessages proto.InternalMessageInfo

func (m *SendInBoxesMessages) GetMessage() *rpc_client.SendMessages {
	if m != nil {
		return m.Message
	}
	return nil
}

type SendMessagesList struct {
	Value []*rpc_client.SendMessages `protobuf:"bytes,1,rep,name=value,proto3" json:"value,omitempty"`
}

func (m *SendMessagesList) Reset()         { *m = SendMessagesList{} }
func (m *SendMessagesList) String() string { return proto.CompactTextString(m) }
func (*SendMessagesList) ProtoMessage()    {}
func (*SendMessagesList) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{16}
}
func (m *SendMessagesList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendMessagesList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendMessagesList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendMessagesList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendMessagesList.Merge(m, src)
}
func (m *SendMessagesList) XXX_Size() int {
	return m.Size()
}
func (m *SendMessagesList) XXX_DiscardUnknown() {
	xxx_messageInfo_SendMessagesList.DiscardUnknown(m)
}

var xxx_messageInfo_SendMessagesList proto.InternalMessageInfo

func (m *SendMessagesList) GetValue() []*rpc_client.SendMessages {
	if m != nil {
		return m.Value
	}
	return nil
}

type ChatReadHistory struct {
	Value *rpc_client.ReadHistory `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ChatReadHistory) Reset()         { *m = ChatReadHistory{} }
func (m *ChatReadHistory) String() string { return proto.CompactTextString(m) }
func (*ChatReadHistory) ProtoMessage()    {}
func (*ChatReadHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{17}
}
func (m *ChatReadHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatReadHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatReadHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatReadHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatReadHistory.Merge(m, src)
}
func (m *ChatReadHistory) XXX_Size() int {
	return m.Size()
}
func (m *ChatReadHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatReadHistory.DiscardUnknown(m)
}

var xxx_messageInfo_ChatReadHistory proto.InternalMessageInfo

func (m *ChatReadHistory) GetValue() *rpc_client.ReadHistory {
	if m != nil {
		return m.Value
	}
	return nil
}

type ReadInMessages struct {
	Value *rpc_client.ReadHistory `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ReadInMessages) Reset()         { *m = ReadInMessages{} }
func (m *ReadInMessages) String() string { return proto.CompactTextString(m) }
func (*ReadInMessages) ProtoMessage()    {}
func (*ReadInMessages) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{18}
}
func (m *ReadInMessages) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadInMessages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadInMessages.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadInMessages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadInMessages.Merge(m, src)
}
func (m *ReadInMessages) XXX_Size() int {
	return m.Size()
}
func (m *ReadInMessages) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadInMessages.DiscardUnknown(m)
}

var xxx_messageInfo_ReadInMessages proto.InternalMessageInfo

func (m *ReadInMessages) GetValue() *rpc_client.ReadHistory {
	if m != nil {
		return m.Value
	}
	return nil
}

type AllChat struct {
	ExceptIds []int64 `protobuf:"varint,1,rep,packed,name=except_ids,json=exceptIds,proto3" json:"except_ids,omitempty"`
	Ids       []int64 `protobuf:"varint,2,rep,packed,name=ids,proto3" json:"ids,omitempty"`
	UserId    int64   `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *AllChat) Reset()         { *m = AllChat{} }
func (m *AllChat) String() string { return proto.CompactTextString(m) }
func (*AllChat) ProtoMessage()    {}
func (*AllChat) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{19}
}
func (m *AllChat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllChat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllChat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllChat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllChat.Merge(m, src)
}
func (m *AllChat) XXX_Size() int {
	return m.Size()
}
func (m *AllChat) XXX_DiscardUnknown() {
	xxx_messageInfo_AllChat.DiscardUnknown(m)
}

var xxx_messageInfo_AllChat proto.InternalMessageInfo

func (m *AllChat) GetExceptIds() []int64 {
	if m != nil {
		return m.ExceptIds
	}
	return nil
}

func (m *AllChat) GetIds() []int64 {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *AllChat) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type ChatPinnedMessage struct {
	PinnedMessage *rpc_client.PinnedMessage `protobuf:"bytes,1,opt,name=pinned_message,json=pinnedMessage,proto3" json:"pinned_message,omitempty"`
}

func (m *ChatPinnedMessage) Reset()         { *m = ChatPinnedMessage{} }
func (m *ChatPinnedMessage) String() string { return proto.CompactTextString(m) }
func (*ChatPinnedMessage) ProtoMessage()    {}
func (*ChatPinnedMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{20}
}
func (m *ChatPinnedMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatPinnedMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatPinnedMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatPinnedMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatPinnedMessage.Merge(m, src)
}
func (m *ChatPinnedMessage) XXX_Size() int {
	return m.Size()
}
func (m *ChatPinnedMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatPinnedMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ChatPinnedMessage proto.InternalMessageInfo

func (m *ChatPinnedMessage) GetPinnedMessage() *rpc_client.PinnedMessage {
	if m != nil {
		return m.PinnedMessage
	}
	return nil
}

type ChatInPinnedMessage struct {
	PinnedMessage *rpc_client.PinnedMessage `protobuf:"bytes,1,opt,name=pinned_message,json=pinnedMessage,proto3" json:"pinned_message,omitempty"`
}

func (m *ChatInPinnedMessage) Reset()         { *m = ChatInPinnedMessage{} }
func (m *ChatInPinnedMessage) String() string { return proto.CompactTextString(m) }
func (*ChatInPinnedMessage) ProtoMessage()    {}
func (*ChatInPinnedMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{21}
}
func (m *ChatInPinnedMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatInPinnedMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatInPinnedMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatInPinnedMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatInPinnedMessage.Merge(m, src)
}
func (m *ChatInPinnedMessage) XXX_Size() int {
	return m.Size()
}
func (m *ChatInPinnedMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatInPinnedMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ChatInPinnedMessage proto.InternalMessageInfo

func (m *ChatInPinnedMessage) GetPinnedMessage() *rpc_client.PinnedMessage {
	if m != nil {
		return m.PinnedMessage
	}
	return nil
}

type CheckUsername struct {
	PeerId   int64  `protobuf:"varint,1,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	PeerType int32  `protobuf:"varint,2,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
}

func (m *CheckUsername) Reset()         { *m = CheckUsername{} }
func (m *CheckUsername) String() string { return proto.CompactTextString(m) }
func (*CheckUsername) ProtoMessage()    {}
func (*CheckUsername) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{22}
}
func (m *CheckUsername) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckUsername) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckUsername.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckUsername) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckUsername.Merge(m, src)
}
func (m *CheckUsername) XXX_Size() int {
	return m.Size()
}
func (m *CheckUsername) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckUsername.DiscardUnknown(m)
}

var xxx_messageInfo_CheckUsername proto.InternalMessageInfo

func (m *CheckUsername) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *CheckUsername) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *CheckUsername) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

type BannedUser struct {
	PeerId    int64 `protobuf:"varint,1,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	UserId    int64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	IsBanned  bool  `protobuf:"varint,3,opt,name=is_banned,json=isBanned,proto3" json:"is_banned,omitempty"`
	IsDeleted bool  `protobuf:"varint,4,opt,name=is_deleted,json=isDeleted,proto3" json:"is_deleted,omitempty"`
	IsLeft    bool  `protobuf:"varint,5,opt,name=is_left,json=isLeft,proto3" json:"is_left,omitempty"`
	Rights    int32 `protobuf:"varint,6,opt,name=rights,proto3" json:"rights,omitempty"`
	UtilDate  int32 `protobuf:"varint,7,opt,name=util_date,json=utilDate,proto3" json:"util_date,omitempty"`
	ChatId    int64 `protobuf:"varint,8,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Date      int32 `protobuf:"varint,9,opt,name=date,proto3" json:"date,omitempty"`
	AuthKeyId int64 `protobuf:"varint,10,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
}

func (m *BannedUser) Reset()         { *m = BannedUser{} }
func (m *BannedUser) String() string { return proto.CompactTextString(m) }
func (*BannedUser) ProtoMessage()    {}
func (*BannedUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{23}
}
func (m *BannedUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BannedUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BannedUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BannedUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BannedUser.Merge(m, src)
}
func (m *BannedUser) XXX_Size() int {
	return m.Size()
}
func (m *BannedUser) XXX_DiscardUnknown() {
	xxx_messageInfo_BannedUser.DiscardUnknown(m)
}

var xxx_messageInfo_BannedUser proto.InternalMessageInfo

func (m *BannedUser) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *BannedUser) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *BannedUser) GetIsBanned() bool {
	if m != nil {
		return m.IsBanned
	}
	return false
}

func (m *BannedUser) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

func (m *BannedUser) GetIsLeft() bool {
	if m != nil {
		return m.IsLeft
	}
	return false
}

func (m *BannedUser) GetRights() int32 {
	if m != nil {
		return m.Rights
	}
	return 0
}

func (m *BannedUser) GetUtilDate() int32 {
	if m != nil {
		return m.UtilDate
	}
	return 0
}

func (m *BannedUser) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *BannedUser) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *BannedUser) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

type EditGeoPoint struct {
	PeerId    int64     `protobuf:"varint,1,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	UserId    int64     `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	GeoPoint  *GeoPoint `protobuf:"bytes,3,opt,name=geo_point,json=geoPoint,proto3" json:"geo_point,omitempty"`
	AuthKeyId int64     `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
}

func (m *EditGeoPoint) Reset()         { *m = EditGeoPoint{} }
func (m *EditGeoPoint) String() string { return proto.CompactTextString(m) }
func (*EditGeoPoint) ProtoMessage()    {}
func (*EditGeoPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{24}
}
func (m *EditGeoPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EditGeoPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EditGeoPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EditGeoPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EditGeoPoint.Merge(m, src)
}
func (m *EditGeoPoint) XXX_Size() int {
	return m.Size()
}
func (m *EditGeoPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_EditGeoPoint.DiscardUnknown(m)
}

var xxx_messageInfo_EditGeoPoint proto.InternalMessageInfo

func (m *EditGeoPoint) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *EditGeoPoint) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *EditGeoPoint) GetGeoPoint() *GeoPoint {
	if m != nil {
		return m.GeoPoint
	}
	return nil
}

func (m *EditGeoPoint) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

type InviteToChannel struct {
	ChatId     int64   `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId     int64   `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId  int64   `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	PeerIdList []int64 `protobuf:"varint,4,rep,packed,name=peer_id_list,json=peerIdList,proto3" json:"peer_id_list,omitempty"`
	Date       int32   `protobuf:"varint,5,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *InviteToChannel) Reset()         { *m = InviteToChannel{} }
func (m *InviteToChannel) String() string { return proto.CompactTextString(m) }
func (*InviteToChannel) ProtoMessage()    {}
func (*InviteToChannel) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{25}
}
func (m *InviteToChannel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InviteToChannel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InviteToChannel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InviteToChannel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InviteToChannel.Merge(m, src)
}
func (m *InviteToChannel) XXX_Size() int {
	return m.Size()
}
func (m *InviteToChannel) XXX_DiscardUnknown() {
	xxx_messageInfo_InviteToChannel.DiscardUnknown(m)
}

var xxx_messageInfo_InviteToChannel proto.InternalMessageInfo

func (m *InviteToChannel) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *InviteToChannel) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *InviteToChannel) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *InviteToChannel) GetPeerIdList() []int64 {
	if m != nil {
		return m.PeerIdList
	}
	return nil
}

func (m *InviteToChannel) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

type DeleteChat struct {
	ChatId    int64 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId    int64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId int64 `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Date      int32 `protobuf:"varint,4,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *DeleteChat) Reset()         { *m = DeleteChat{} }
func (m *DeleteChat) String() string { return proto.CompactTextString(m) }
func (*DeleteChat) ProtoMessage()    {}
func (*DeleteChat) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{26}
}
func (m *DeleteChat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteChat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteChat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteChat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteChat.Merge(m, src)
}
func (m *DeleteChat) XXX_Size() int {
	return m.Size()
}
func (m *DeleteChat) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteChat.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteChat proto.InternalMessageInfo

func (m *DeleteChat) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *DeleteChat) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteChat) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *DeleteChat) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

type HistoryHidden struct {
	ChatId    int64 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId    int64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId int64 `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Date      int32 `protobuf:"varint,4,opt,name=date,proto3" json:"date,omitempty"`
	Enabled   bool  `protobuf:"varint,5,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *HistoryHidden) Reset()         { *m = HistoryHidden{} }
func (m *HistoryHidden) String() string { return proto.CompactTextString(m) }
func (*HistoryHidden) ProtoMessage()    {}
func (*HistoryHidden) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{27}
}
func (m *HistoryHidden) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HistoryHidden) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HistoryHidden.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HistoryHidden) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistoryHidden.Merge(m, src)
}
func (m *HistoryHidden) XXX_Size() int {
	return m.Size()
}
func (m *HistoryHidden) XXX_DiscardUnknown() {
	xxx_messageInfo_HistoryHidden.DiscardUnknown(m)
}

var xxx_messageInfo_HistoryHidden proto.InternalMessageInfo

func (m *HistoryHidden) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *HistoryHidden) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *HistoryHidden) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *HistoryHidden) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *HistoryHidden) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

type UpdateUsername struct {
	ChatId    int64  `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId    int64  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId int64  `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Username  string `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
}

func (m *UpdateUsername) Reset()         { *m = UpdateUsername{} }
func (m *UpdateUsername) String() string { return proto.CompactTextString(m) }
func (*UpdateUsername) ProtoMessage()    {}
func (*UpdateUsername) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{28}
}
func (m *UpdateUsername) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUsername) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUsername.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateUsername) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUsername.Merge(m, src)
}
func (m *UpdateUsername) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUsername) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUsername.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUsername proto.InternalMessageInfo

func (m *UpdateUsername) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *UpdateUsername) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UpdateUsername) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *UpdateUsername) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

type DeleteMessagesUpdates struct {
	PeerId int64   `protobuf:"varint,1,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	UserId int64   `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Ids    []int32 `protobuf:"varint,3,rep,packed,name=ids,proto3" json:"ids,omitempty"`
	Date   int32   `protobuf:"varint,4,opt,name=date,proto3" json:"date,omitempty"`
	Pts    int32   `protobuf:"varint,5,opt,name=pts,proto3" json:"pts,omitempty"`
}

func (m *DeleteMessagesUpdates) Reset()         { *m = DeleteMessagesUpdates{} }
func (m *DeleteMessagesUpdates) String() string { return proto.CompactTextString(m) }
func (*DeleteMessagesUpdates) ProtoMessage()    {}
func (*DeleteMessagesUpdates) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{29}
}
func (m *DeleteMessagesUpdates) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteMessagesUpdates) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteMessagesUpdates.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteMessagesUpdates) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMessagesUpdates.Merge(m, src)
}
func (m *DeleteMessagesUpdates) XXX_Size() int {
	return m.Size()
}
func (m *DeleteMessagesUpdates) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMessagesUpdates.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMessagesUpdates proto.InternalMessageInfo

func (m *DeleteMessagesUpdates) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *DeleteMessagesUpdates) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteMessagesUpdates) GetIds() []int32 {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *DeleteMessagesUpdates) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *DeleteMessagesUpdates) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

type DeleteHistory struct {
	ChatId    int64 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId    int64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId int64 `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Date      int32 `protobuf:"varint,4,opt,name=date,proto3" json:"date,omitempty"`
	MaxId     int32 `protobuf:"varint,5,opt,name=max_id,json=maxId,proto3" json:"max_id,omitempty"`
}

func (m *DeleteHistory) Reset()         { *m = DeleteHistory{} }
func (m *DeleteHistory) String() string { return proto.CompactTextString(m) }
func (*DeleteHistory) ProtoMessage()    {}
func (*DeleteHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{30}
}
func (m *DeleteHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteHistory.Merge(m, src)
}
func (m *DeleteHistory) XXX_Size() int {
	return m.Size()
}
func (m *DeleteHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteHistory.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteHistory proto.InternalMessageInfo

func (m *DeleteHistory) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *DeleteHistory) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteHistory) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *DeleteHistory) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *DeleteHistory) GetMaxId() int32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

type DeleteMessages struct {
	ChatId    int64   `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId    int64   `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId int64   `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Date      int32   `protobuf:"varint,4,opt,name=date,proto3" json:"date,omitempty"`
	Ids       []int32 `protobuf:"varint,5,rep,packed,name=ids,proto3" json:"ids,omitempty"`
}

func (m *DeleteMessages) Reset()         { *m = DeleteMessages{} }
func (m *DeleteMessages) String() string { return proto.CompactTextString(m) }
func (*DeleteMessages) ProtoMessage()    {}
func (*DeleteMessages) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{31}
}
func (m *DeleteMessages) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteMessages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteMessages.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteMessages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMessages.Merge(m, src)
}
func (m *DeleteMessages) XXX_Size() int {
	return m.Size()
}
func (m *DeleteMessages) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMessages.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMessages proto.InternalMessageInfo

func (m *DeleteMessages) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *DeleteMessages) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteMessages) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *DeleteMessages) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *DeleteMessages) GetIds() []int32 {
	if m != nil {
		return m.Ids
	}
	return nil
}

type DeleteUserHistory struct {
	ChatId    int64 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId    int64 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId int64 `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Date      int32 `protobuf:"varint,4,opt,name=date,proto3" json:"date,omitempty"`
	PeerId    int64 `protobuf:"varint,5,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
}

func (m *DeleteUserHistory) Reset()         { *m = DeleteUserHistory{} }
func (m *DeleteUserHistory) String() string { return proto.CompactTextString(m) }
func (*DeleteUserHistory) ProtoMessage()    {}
func (*DeleteUserHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{32}
}
func (m *DeleteUserHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteUserHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteUserHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteUserHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteUserHistory.Merge(m, src)
}
func (m *DeleteUserHistory) XXX_Size() int {
	return m.Size()
}
func (m *DeleteUserHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteUserHistory.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteUserHistory proto.InternalMessageInfo

func (m *DeleteUserHistory) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *DeleteUserHistory) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteUserHistory) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *DeleteUserHistory) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *DeleteUserHistory) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

type GetParticipants struct {
	ChatId int64  `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId int64  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Filter int32  `protobuf:"varint,3,opt,name=filter,proto3" json:"filter,omitempty"`
	Offset int32  `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
	Limit  int32  `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	Q      string `protobuf:"bytes,6,opt,name=q,proto3" json:"q,omitempty"`
}

func (m *GetParticipants) Reset()         { *m = GetParticipants{} }
func (m *GetParticipants) String() string { return proto.CompactTextString(m) }
func (*GetParticipants) ProtoMessage()    {}
func (*GetParticipants) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c585a45e2093e54, []int{33}
}
func (m *GetParticipants) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetParticipants) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetParticipants.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetParticipants) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetParticipants.Merge(m, src)
}
func (m *GetParticipants) XXX_Size() int {
	return m.Size()
}
func (m *GetParticipants) XXX_DiscardUnknown() {
	xxx_messageInfo_GetParticipants.DiscardUnknown(m)
}

var xxx_messageInfo_GetParticipants proto.InternalMessageInfo

func (m *GetParticipants) GetChatId() int64 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *GetParticipants) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetParticipants) GetFilter() int32 {
	if m != nil {
		return m.Filter
	}
	return 0
}

func (m *GetParticipants) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *GetParticipants) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GetParticipants) GetQ() string {
	if m != nil {
		return m.Q
	}
	return ""
}

func init() {
	proto.RegisterType((*Chat)(nil), "rpc_client.Chat")
	proto.RegisterType((*ChatList)(nil), "rpc_client.ChatList")
	proto.RegisterType((*GeoPoint)(nil), "rpc_client.GeoPoint")
	proto.RegisterType((*CreateChat)(nil), "rpc_client.CreateChat")
	proto.RegisterType((*FullChat)(nil), "rpc_client.FullChat")
	proto.RegisterType((*ChatCommon)(nil), "rpc_client.ChatCommon")
	proto.RegisterType((*EditTitle)(nil), "rpc_client.EditTitle")
	proto.RegisterType((*EditAbout)(nil), "rpc_client.EditAbout")
	proto.RegisterType((*EditPhoto)(nil), "rpc_client.EditPhoto")
	proto.RegisterType((*BannedRights)(nil), "rpc_client.BannedRights")
	proto.RegisterType((*EditAdmin)(nil), "rpc_client.EditAdmin")
	proto.RegisterType((*ChatByName)(nil), "rpc_client.ChatByName")
	proto.RegisterType((*AddUser)(nil), "rpc_client.AddUser")
	proto.RegisterType((*DeleteUser)(nil), "rpc_client.DeleteUser")
	proto.RegisterType((*SendOutboxesMessages)(nil), "rpc_client.SendOutboxesMessages")
	proto.RegisterType((*SendInBoxesMessages)(nil), "rpc_client.SendInBoxesMessages")
	proto.RegisterType((*SendMessagesList)(nil), "rpc_client.SendMessagesList")
	proto.RegisterType((*ChatReadHistory)(nil), "rpc_client.ChatReadHistory")
	proto.RegisterType((*ReadInMessages)(nil), "rpc_client.ReadInMessages")
	proto.RegisterType((*AllChat)(nil), "rpc_client.AllChat")
	proto.RegisterType((*ChatPinnedMessage)(nil), "rpc_client.ChatPinnedMessage")
	proto.RegisterType((*ChatInPinnedMessage)(nil), "rpc_client.ChatInPinnedMessage")
	proto.RegisterType((*CheckUsername)(nil), "rpc_client.CheckUsername")
	proto.RegisterType((*BannedUser)(nil), "rpc_client.BannedUser")
	proto.RegisterType((*EditGeoPoint)(nil), "rpc_client.EditGeoPoint")
	proto.RegisterType((*InviteToChannel)(nil), "rpc_client.InviteToChannel")
	proto.RegisterType((*DeleteChat)(nil), "rpc_client.DeleteChat")
	proto.RegisterType((*HistoryHidden)(nil), "rpc_client.HistoryHidden")
	proto.RegisterType((*UpdateUsername)(nil), "rpc_client.UpdateUsername")
	proto.RegisterType((*DeleteMessagesUpdates)(nil), "rpc_client.DeleteMessagesUpdates")
	proto.RegisterType((*DeleteHistory)(nil), "rpc_client.DeleteHistory")
	proto.RegisterType((*DeleteMessages)(nil), "rpc_client.DeleteMessages")
	proto.RegisterType((*DeleteUserHistory)(nil), "rpc_client.DeleteUserHistory")
	proto.RegisterType((*GetParticipants)(nil), "rpc_client.GetParticipants")
}

func init() { proto.RegisterFile("chat.proto", fileDescriptor_8c585a45e2093e54) }

var fileDescriptor_8c585a45e2093e54 = []byte{
	// 1390 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x4d, 0x6f, 0x1c, 0xb5,
	0x1b, 0xaf, 0x77, 0x76, 0x76, 0x67, 0x9f, 0xbc, 0x76, 0x9a, 0xb6, 0xdb, 0xb4, 0xff, 0x34, 0xea,
	0x29, 0xd2, 0x9f, 0x6e, 0xd4, 0x70, 0xe3, 0x44, 0x93, 0x96, 0x76, 0x45, 0x5f, 0xa2, 0x69, 0x2b,
	0x2a, 0x2e, 0x83, 0x77, 0xc7, 0xbb, 0x6b, 0x75, 0xde, 0x3a, 0xf6, 0xb6, 0xd9, 0x9e, 0x90, 0x38,
	0x21, 0x21, 0xc1, 0x05, 0x04, 0x48, 0x48, 0xb4, 0x08, 0x71, 0xe1, 0xc6, 0x81, 0xaf, 0x00, 0xb7,
	0x7e, 0x04, 0xe8, 0x27, 0xe0, 0x23, 0x20, 0xdb, 0x33, 0x59, 0x8f, 0xc9, 0xa4, 0x90, 0x26, 0xb9,
	0xf9, 0xf1, 0x3c, 0xcf, 0xe3, 0x9f, 0x7f, 0xb6, 0x7f, 0x8f, 0x3d, 0x00, 0xfd, 0x11, 0xe6, 0x9d,
	0x34, 0x4b, 0x78, 0xe2, 0x42, 0x96, 0xf6, 0xfd, 0x7e, 0x48, 0x49, 0xcc, 0x97, 0x2f, 0x0f, 0x29,
	0x1f, 0x8d, 0x7b, 0x9d, 0x7e, 0x12, 0xad, 0x0f, 0x93, 0x61, 0xb2, 0x2e, 0x5d, 0x7a, 0xe3, 0x81,
	0xb4, 0xa4, 0x21, 0x5b, 0x2a, 0x74, 0xf9, 0x02, 0x23, 0xd9, 0x13, 0xda, 0x27, 0xeb, 0x01, 0xe6,
	0x78, 0x5d, 0xe4, 0x5c, 0x9f, 0x26, 0x5e, 0x5e, 0xdb, 0xfb, 0xab, 0x9f, 0xe2, 0x8c, 0xd3, 0x3e,
	0x4d, 0x71, 0x5c, 0x78, 0x9e, 0x4a, 0x47, 0x09, 0x4f, 0xfc, 0x34, 0x4b, 0x06, 0x34, 0x24, 0x79,
	0xe7, 0x22, 0xeb, 0x8f, 0x48, 0x84, 0x3b, 0x11, 0x1b, 0xaa, 0x9e, 0x4b, 0x9f, 0x22, 0xa8, 0x6f,
	0x8d, 0x30, 0x77, 0xdf, 0x82, 0x96, 0xcc, 0x24, 0x12, 0xb7, 0xd1, 0x2a, 0x5a, 0x9b, 0xd9, 0x58,
	0xe8, 0x08, 0xc3, 0x97, 0xc3, 0x0b, 0x1f, 0xcf, 0x11, 0xcd, 0x6b, 0x98, 0x63, 0xf7, 0x3a, 0x2c,
	0x6a, 0x43, 0xfa, 0x21, 0x65, 0xbc, 0x5d, 0x5b, 0xb5, 0xd6, 0x66, 0x36, 0x96, 0x8d, 0xa0, 0xed,
	0xa9, 0x9b, 0xb7, 0xa0, 0xc5, 0xdc, 0xa2, 0x8c, 0xbf, 0x33, 0xfb, 0xf2, 0xf9, 0xc5, 0x13, 0x5f,
	0xbc, 0xb8, 0x78, 0xe2, 0xeb, 0x17, 0x17, 0x4f, 0x5c, 0xda, 0x04, 0x47, 0x44, 0x88, 0x2f, 0xee,
	0x1a, 0x34, 0x9e, 0xe0, 0x70, 0x4c, 0x58, 0x1b, 0xc9, 0xb4, 0x8b, 0x9d, 0x29, 0xa5, 0x0a, 0x4c,
	0xfe, 0xdd, 0xc8, 0xf1, 0x10, 0x9c, 0x1b, 0x24, 0xd9, 0x4e, 0x68, 0xcc, 0xdd, 0x45, 0xb0, 0x42,
	0xcc, 0xe5, 0x64, 0x90, 0x27, 0x9a, 0xae, 0x0b, 0xf5, 0x30, 0x89, 0x87, 0xed, 0x9a, 0xec, 0x92,
	0x6d, 0xb7, 0x0d, 0x4d, 0x1c, 0x04, 0x19, 0x61, 0xac, 0x6d, 0xad, 0xa2, 0xb5, 0x96, 0x57, 0x98,
	0x46, 0xe6, 0x4f, 0x6a, 0x00, 0x5b, 0x19, 0xc1, 0x9c, 0x48, 0xbe, 0xce, 0x42, 0x73, 0xcc, 0x48,
	0xe6, 0xd3, 0x40, 0x0e, 0x60, 0x79, 0x0d, 0x61, 0x76, 0x03, 0x77, 0x05, 0x66, 0xf0, 0x98, 0x8f,
	0xfc, 0x47, 0x64, 0x22, 0x3e, 0xd6, 0xe4, 0xc7, 0x96, 0xe8, 0x7a, 0x9f, 0x4c, 0xba, 0x81, 0x08,
	0x4c, 0x89, 0x0a, 0xb4, 0x56, 0x2d, 0x11, 0x28, 0xcc, 0x6e, 0xe0, 0x2e, 0x81, 0xcd, 0x29, 0x0f,
	0x49, 0xbb, 0x2e, 0x61, 0x28, 0xc3, 0xbd, 0x04, 0x73, 0x72, 0x5d, 0x18, 0x7d, 0x46, 0xfc, 0x08,
	0xef, 0xb4, 0xed, 0x55, 0xb4, 0x66, 0x7b, 0x33, 0xa2, 0xf3, 0x1e, 0x7d, 0x46, 0x6e, 0xe3, 0x1d,
	0x31, 0xad, 0x00, 0x73, 0xd2, 0x6e, 0xc8, 0x4f, 0xb2, 0xed, 0x5e, 0x81, 0xd6, 0x90, 0x24, 0x7e,
	0x2a, 0x98, 0x68, 0x37, 0xe5, 0x7a, 0x2e, 0xe9, 0x1c, 0x16, 0x2c, 0x79, 0xce, 0xb0, 0xe0, 0x6b,
	0x09, 0xec, 0x10, 0x4f, 0x48, 0xd6, 0x76, 0x64, 0x1e, 0x65, 0x18, 0x2c, 0x5c, 0x01, 0xe7, 0xbd,
	0x71, 0x18, 0x16, 0x14, 0x48, 0x68, 0x53, 0x0a, 0x84, 0xd9, 0x0d, 0x8c, 0x90, 0x8f, 0x00, 0x84,
	0xfb, 0x56, 0x12, 0x45, 0x49, 0x5c, 0xcd, 0xdb, 0x69, 0x68, 0x44, 0x78, 0xa7, 0xa0, 0xcc, 0xf6,
	0xec, 0x08, 0xef, 0x28, 0x56, 0x42, 0x1a, 0x51, 0x2e, 0x17, 0x47, 0x80, 0x12, 0x86, 0x31, 0xc2,
	0x97, 0x08, 0x5a, 0xd7, 0x03, 0xca, 0xef, 0x4b, 0xc6, 0xaa, 0x60, 0x4d, 0x09, 0xae, 0xe9, 0x04,
	0x6b, 0x80, 0xac, 0xfd, 0x16, 0xb2, 0x6e, 0x2e, 0x64, 0xc1, 0xba, 0x3d, 0x65, 0xbd, 0x02, 0xd7,
	0xd5, 0x5e, 0x32, 0xe6, 0xfb, 0xe2, 0xc2, 0xc2, 0xa3, 0xc0, 0x85, 0x0b, 0xf7, 0xa3, 0xc2, 0xf5,
	0x73, 0x8e, 0x6b, 0x5b, 0x48, 0x44, 0x35, 0xae, 0xff, 0x83, 0x2d, 0x45, 0x44, 0xe2, 0x9a, 0xd9,
	0x38, 0xad, 0x4e, 0xf6, 0x80, 0x75, 0x64, 0xdc, 0xb6, 0x52, 0x16, 0x4f, 0xf9, 0x1c, 0x25, 0xdc,
	0x5f, 0x11, 0xcc, 0x6e, 0xe2, 0x38, 0x26, 0x81, 0x47, 0x87, 0x23, 0xce, 0xaa, 0x11, 0x9f, 0x81,
	0x46, 0x26, 0x5d, 0xf2, 0x3d, 0x94, 0x5b, 0x87, 0x0a, 0xce, 0x3d, 0x0f, 0xad, 0x31, 0xa7, 0xa1,
	0xaf, 0x1d, 0x39, 0x47, 0x74, 0x5c, 0xfb, 0x27, 0xf2, 0xdf, 0x8b, 0x0d, 0x10, 0x44, 0x34, 0xae,
	0x86, 0xad, 0x49, 0x82, 0x92, 0x8b, 0x42, 0x12, 0xce, 0x81, 0x43, 0x99, 0x8f, 0x45, 0xb4, 0x04,
	0xee, 0x78, 0x4d, 0xca, 0x76, 0x93, 0x15, 0x53, 0xaa, 0xef, 0x37, 0x25, 0xbb, 0x6a, 0x4a, 0xba,
	0x58, 0x2c, 0x81, 0x2d, 0x99, 0x2a, 0x4e, 0xbe, 0x34, 0x8c, 0xb9, 0xdc, 0x55, 0xc7, 0x78, 0x73,
	0x72, 0x07, 0x47, 0xc4, 0x5d, 0x06, 0x47, 0x8c, 0x17, 0xe3, 0x88, 0xc8, 0xc9, 0xb4, 0xbc, 0x5d,
	0x5b, 0x87, 0x56, 0xd3, 0xa1, 0x19, 0x09, 0x7f, 0x41, 0xd0, 0xbc, 0x1a, 0x04, 0x0f, 0x18, 0xc9,
	0xaa, 0x55, 0x41, 0xe3, 0xac, 0x56, 0xc5, 0x99, 0x55, 0xe2, 0xec, 0x3c, 0xb4, 0x06, 0x4f, 0x03,
	0x5f, 0x89, 0x46, 0x5d, 0x2d, 0xcf, 0xe0, 0x69, 0x70, 0x4b, 0xd8, 0x07, 0x21, 0xc7, 0x40, 0xfd,
	0x0d, 0x02, 0xb8, 0x46, 0x42, 0xc2, 0xc9, 0x61, 0x03, 0x7f, 0xf3, 0x83, 0xf2, 0x10, 0x96, 0xee,
	0x91, 0x38, 0xb8, 0x3b, 0xe6, 0xbd, 0x64, 0x87, 0xb0, 0xdb, 0x84, 0x31, 0x3c, 0x24, 0xcc, 0xdd,
	0x80, 0x66, 0xa4, 0xda, 0x79, 0x65, 0x6f, 0xeb, 0x95, 0x40, 0x84, 0x14, 0xae, 0x5e, 0xe1, 0x68,
	0x64, 0xfe, 0x00, 0x4e, 0x09, 0xb7, 0x6e, 0xbc, 0x79, 0xc8, 0x89, 0xb7, 0x61, 0x51, 0x77, 0x93,
	0xb5, 0xbf, 0x03, 0xb6, 0xac, 0xed, 0x79, 0xe9, 0xaf, 0xce, 0xa9, 0xdc, 0x8c, 0x8c, 0x77, 0x60,
	0x41, 0xde, 0x0f, 0x08, 0x0e, 0x6e, 0x52, 0xc6, 0x93, 0x6c, 0xe2, 0x5e, 0x9e, 0x26, 0x14, 0x20,
	0xcf, 0xea, 0x09, 0x35, 0xbf, 0xbd, 0xf3, 0xdd, 0x86, 0x79, 0xe1, 0xd3, 0x8d, 0x77, 0x67, 0xfd,
	0x46, 0xe9, 0x30, 0x34, 0xaf, 0xe6, 0xf5, 0xf3, 0x7f, 0x00, 0x64, 0xa7, 0x4f, 0x52, 0xb1, 0x49,
	0xd4, 0x3d, 0xc7, 0xf2, 0x5a, 0xaa, 0xa7, 0x1b, 0x30, 0x71, 0x7d, 0x11, 0xfd, 0x35, 0xd9, 0x2f,
	0x9a, 0x95, 0x32, 0x66, 0x0c, 0xd1, 0x87, 0x93, 0xf2, 0xe6, 0x45, 0x85, 0x64, 0xe6, 0xa8, 0xdd,
	0x77, 0x61, 0x3e, 0x95, 0x1d, 0x7e, 0x79, 0xc5, 0xce, 0xe9, 0xe8, 0x4b, 0x21, 0xde, 0x5c, 0xaa,
	0x9b, 0xc6, 0x20, 0x04, 0x4e, 0x89, 0x41, 0xba, 0xf1, 0xd1, 0x0e, 0x93, 0xc0, 0xdc, 0xd6, 0x88,
	0xf4, 0x1f, 0x3d, 0xd0, 0xc4, 0xa5, 0x38, 0x3e, 0xc8, 0x3c, 0xf7, 0xf2, 0x03, 0x9f, 0xa4, 0x24,
	0x97, 0x7f, 0x47, 0x74, 0xdc, 0x9f, 0xa4, 0x65, 0xb9, 0xb2, 0xca, 0x72, 0x65, 0x0c, 0xf8, 0x43,
	0x0d, 0x40, 0x15, 0x9b, 0xe2, 0x7c, 0xef, 0x3d, 0x5c, 0x95, 0xc8, 0x09, 0x1c, 0x94, 0xf9, 0x3d,
	0x99, 0x22, 0x17, 0x6d, 0x87, 0x32, 0x95, 0x52, 0x2c, 0x39, 0x65, 0x7e, 0x20, 0xf5, 0x43, 0x1d,
	0x71, 0xc7, 0x6b, 0x51, 0xa6, 0x04, 0x45, 0x26, 0xa5, 0xcc, 0x0f, 0xc9, 0x80, 0xcb, 0x53, 0xee,
	0x78, 0x0d, 0xca, 0x6e, 0x91, 0x01, 0xd7, 0x0a, 0x5b, 0xa3, 0x54, 0xd8, 0x4a, 0xb5, 0xa8, 0x59,
	0xae, 0x45, 0xba, 0x04, 0x39, 0x25, 0x09, 0x2a, 0x94, 0xa4, 0xa5, 0x95, 0x00, 0x43, 0x7d, 0xc0,
	0x50, 0x1f, 0x83, 0xa5, 0xe7, 0x08, 0x66, 0x45, 0x61, 0xdb, 0xbd, 0x6b, 0xff, 0x77, 0x9e, 0x4a,
	0x17, 0x54, 0xeb, 0x5f, 0x5d, 0x50, 0x5f, 0xa3, 0x90, 0x06, 0xc6, 0x9f, 0x10, 0x2c, 0x74, 0xe3,
	0x27, 0x94, 0x93, 0xfb, 0xc9, 0xd6, 0x48, 0xf0, 0x1f, 0xee, 0x5b, 0x82, 0xf7, 0x86, 0x69, 0x8c,
	0x69, 0x99, 0xaa, 0xbc, 0x0a, 0xb3, 0xf9, 0xc4, 0xd5, 0x2b, 0xa8, 0x2e, 0x8f, 0x2b, 0xa8, 0xd9,
	0x4b, 0x39, 0x7b, 0xbd, 0x6e, 0x7f, 0xbc, 0x5b, 0x53, 0xf6, 0xbd, 0x57, 0x1f, 0x1c, 0x64, 0x01,
	0xa1, 0x5e, 0x09, 0xe1, 0x3b, 0x04, 0x73, 0xb9, 0x6e, 0xdd, 0xa4, 0x41, 0x40, 0xe2, 0xe3, 0x41,
	0x21, 0x5e, 0x5f, 0x24, 0xc6, 0xbd, 0x90, 0x04, 0xf9, 0x8e, 0x2f, 0x4c, 0x03, 0xdf, 0x67, 0x08,
	0xe6, 0x1f, 0xa4, 0x22, 0x44, 0x57, 0x82, 0x43, 0x06, 0xa8, 0xab, 0x44, 0x7d, 0x5f, 0x95, 0xf8,
	0x1c, 0xc1, 0x69, 0xb5, 0x62, 0x45, 0x55, 0x50, 0xe0, 0xd8, 0x01, 0x0e, 0x42, 0xae, 0xf3, 0xe2,
	0x31, 0x68, 0x2b, 0x9d, 0xdf, 0x8b, 0xa8, 0x45, 0xb0, 0x52, 0xce, 0xf2, 0x4d, 0x24, 0x9a, 0x06,
	0xa2, 0x6f, 0x11, 0xcc, 0x29, 0x44, 0x45, 0xd5, 0x3b, 0x9e, 0x05, 0x9c, 0x3e, 0xdb, 0x6c, 0xed,
	0xd9, 0x66, 0x80, 0xfb, 0x0a, 0xc1, 0x7c, 0x99, 0xae, 0x63, 0x42, 0x97, 0x73, 0x6b, 0xef, 0x72,
	0x6b, 0x00, 0xfb, 0x1e, 0xc1, 0xc9, 0xe9, 0x6d, 0xee, 0x78, 0x99, 0xd3, 0x76, 0x8a, 0xad, 0xef,
	0x14, 0x03, 0xe2, 0x8f, 0x08, 0x16, 0x6e, 0x10, 0xfd, 0x3f, 0xca, 0x41, 0xc8, 0x3b, 0x03, 0x8d,
	0x01, 0x0d, 0x39, 0xc9, 0xf2, 0x77, 0x74, 0x6e, 0x89, 0xfe, 0x64, 0x30, 0x60, 0xa4, 0xb8, 0x2a,
	0xe7, 0xd6, 0xf4, 0xd9, 0x6d, 0x6b, 0xcf, 0x6e, 0x77, 0x16, 0xd0, 0x63, 0x59, 0x81, 0x5a, 0x1e,
	0x7a, 0x5c, 0xc6, 0xb9, 0x79, 0xe1, 0xaf, 0x3f, 0x57, 0xd0, 0x6f, 0xaf, 0x56, 0xd0, 0xcb, 0x57,
	0x2b, 0xe8, 0x8f, 0x57, 0x2b, 0xe8, 0x43, 0xed, 0x2f, 0x58, 0xaf, 0x21, 0x7f, 0x37, 0xbd, 0xfd,
	0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1e, 0x09, 0x5b, 0x22, 0x26, 0x13, 0x00, 0x00,
}

func (this *Chat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&rpc_client.Chat{")
	if this.ChatData != nil {
		s = append(s, "ChatData: "+fmt.Sprintf("%#v", this.ChatData)+",\n")
	}
	if this.ParticipantList != nil {
		s = append(s, "ParticipantList: "+fmt.Sprintf("%#v", this.ParticipantList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChatList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&rpc_client.ChatList{")
	if this.Values != nil {
		s = append(s, "Values: "+fmt.Sprintf("%#v", this.Values)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GeoPoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&rpc_client.GeoPoint{")
	s = append(s, "Lat: "+fmt.Sprintf("%#v", this.Lat)+",\n")
	s = append(s, "Long: "+fmt.Sprintf("%#v", this.Long)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateChat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&rpc_client.CreateChat{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "ChatSizeMax: "+fmt.Sprintf("%#v", this.ChatSizeMax)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	if this.GeoPoint != nil {
		s = append(s, "GeoPoint: "+fmt.Sprintf("%#v", this.GeoPoint)+",\n")
	}
	s = append(s, "Layer: "+fmt.Sprintf("%#v", this.Layer)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FullChat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&rpc_client.FullChat{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChatCommon) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&rpc_client.ChatCommon{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "MaxId: "+fmt.Sprintf("%#v", this.MaxId)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EditTitle) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&rpc_client.EditTitle{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EditAbout) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&rpc_client.EditAbout{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "About: "+fmt.Sprintf("%#v", this.About)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EditPhoto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&rpc_client.EditPhoto{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	if this.Photo != nil {
		s = append(s, "Photo: "+fmt.Sprintf("%#v", this.Photo)+",\n")
	}
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BannedRights) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&rpc_client.BannedRights{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "Rights: "+fmt.Sprintf("%#v", this.Rights)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "UtilDate: "+fmt.Sprintf("%#v", this.UtilDate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EditAdmin) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&rpc_client.EditAdmin{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "IsAdmin: "+fmt.Sprintf("%#v", this.IsAdmin)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "Right: "+fmt.Sprintf("%#v", this.Right)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChatByName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&rpc_client.ChatByName{")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AddUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&rpc_client.AddUser{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "FwdLimit: "+fmt.Sprintf("%#v", this.FwdLimit)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&rpc_client.DeleteUser{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendOutboxesMessages) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&rpc_client.SendOutboxesMessages{")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendInBoxesMessages) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&rpc_client.SendInBoxesMessages{")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendMessagesList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&rpc_client.SendMessagesList{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChatReadHistory) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&rpc_client.ChatReadHistory{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadInMessages) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&rpc_client.ReadInMessages{")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AllChat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&rpc_client.AllChat{")
	s = append(s, "ExceptIds: "+fmt.Sprintf("%#v", this.ExceptIds)+",\n")
	s = append(s, "Ids: "+fmt.Sprintf("%#v", this.Ids)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChatPinnedMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&rpc_client.ChatPinnedMessage{")
	if this.PinnedMessage != nil {
		s = append(s, "PinnedMessage: "+fmt.Sprintf("%#v", this.PinnedMessage)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChatInPinnedMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&rpc_client.ChatInPinnedMessage{")
	if this.PinnedMessage != nil {
		s = append(s, "PinnedMessage: "+fmt.Sprintf("%#v", this.PinnedMessage)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckUsername) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&rpc_client.CheckUsername{")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "PeerType: "+fmt.Sprintf("%#v", this.PeerType)+",\n")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BannedUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&rpc_client.BannedUser{")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "IsBanned: "+fmt.Sprintf("%#v", this.IsBanned)+",\n")
	s = append(s, "IsDeleted: "+fmt.Sprintf("%#v", this.IsDeleted)+",\n")
	s = append(s, "IsLeft: "+fmt.Sprintf("%#v", this.IsLeft)+",\n")
	s = append(s, "Rights: "+fmt.Sprintf("%#v", this.Rights)+",\n")
	s = append(s, "UtilDate: "+fmt.Sprintf("%#v", this.UtilDate)+",\n")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EditGeoPoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&rpc_client.EditGeoPoint{")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	if this.GeoPoint != nil {
		s = append(s, "GeoPoint: "+fmt.Sprintf("%#v", this.GeoPoint)+",\n")
	}
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InviteToChannel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&rpc_client.InviteToChannel{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "PeerIdList: "+fmt.Sprintf("%#v", this.PeerIdList)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteChat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&rpc_client.DeleteChat{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HistoryHidden) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&rpc_client.HistoryHidden{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "Enabled: "+fmt.Sprintf("%#v", this.Enabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateUsername) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&rpc_client.UpdateUsername{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteMessagesUpdates) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&rpc_client.DeleteMessagesUpdates{")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "Ids: "+fmt.Sprintf("%#v", this.Ids)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "Pts: "+fmt.Sprintf("%#v", this.Pts)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteHistory) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&rpc_client.DeleteHistory{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "MaxId: "+fmt.Sprintf("%#v", this.MaxId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteMessages) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&rpc_client.DeleteMessages{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "Ids: "+fmt.Sprintf("%#v", this.Ids)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteUserHistory) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&rpc_client.DeleteUserHistory{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetParticipants) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&rpc_client.GetParticipants{")
	s = append(s, "ChatId: "+fmt.Sprintf("%#v", this.ChatId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	s = append(s, "Offset: "+fmt.Sprintf("%#v", this.Offset)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Q: "+fmt.Sprintf("%#v", this.Q)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringChat(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Chat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Chat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParticipantList) > 0 {
		for iNdEx := len(m.ParticipantList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ParticipantList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ChatData != nil {
		{
			size, err := m.ChatData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChatList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GeoPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeoPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintChat(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Long != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Long))))
		i--
		dAtA[i] = 0x11
	}
	if m.Lat != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lat))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *CreateChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateChat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateChat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Layer != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x40
	}
	if m.GeoPoint != nil {
		{
			size, err := m.GeoPoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x30
	}
	if m.ChatSizeMax != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatSizeMax))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintChat(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PeerId) > 0 {
		dAtA4 := make([]byte, len(m.PeerId)*10)
		var j3 int
		for _, num1 := range m.PeerId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintChat(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FullChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FullChat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FullChat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChatCommon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatCommon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatCommon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.MaxId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EditTitle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditTitle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EditTitle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x28
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintChat(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EditAbout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditAbout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EditAbout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x28
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.About) > 0 {
		i -= len(m.About)
		copy(dAtA[i:], m.About)
		i = encodeVarintChat(dAtA, i, uint64(len(m.About)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EditPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditPhoto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EditPhoto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x28
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Photo != nil {
		{
			size, err := m.Photo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BannedRights) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BannedRights) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BannedRights) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UtilDate != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UtilDate))
		i--
		dAtA[i] = 0x30
	}
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x28
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Rights != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Rights))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EditAdmin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditAdmin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EditAdmin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Right != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Right))
		i--
		dAtA[i] = 0x40
	}
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x30
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x28
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x20
	}
	if m.IsAdmin {
		i--
		if m.IsAdmin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.PeerId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChatByName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatByName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatByName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintChat(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x30
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x28
	}
	if m.FwdLimit != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.FwdLimit))
		i--
		dAtA[i] = 0x20
	}
	if m.PeerId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x18
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x28
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.PeerId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x18
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SendOutboxesMessages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendOutboxesMessages) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendOutboxesMessages) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendInBoxesMessages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendInBoxesMessages) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendInBoxesMessages) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendMessagesList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMessagesList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendMessagesList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Value[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ChatReadHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatReadHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatReadHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReadInMessages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadInMessages) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadInMessages) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AllChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllChat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllChat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ids) > 0 {
		dAtA11 := make([]byte, len(m.Ids)*10)
		var j10 int
		for _, num1 := range m.Ids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintChat(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ExceptIds) > 0 {
		dAtA13 := make([]byte, len(m.ExceptIds)*10)
		var j12 int
		for _, num1 := range m.ExceptIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintChat(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChatPinnedMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatPinnedMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatPinnedMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PinnedMessage != nil {
		{
			size, err := m.PinnedMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChatInPinnedMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatInPinnedMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatInPinnedMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PinnedMessage != nil {
		{
			size, err := m.PinnedMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckUsername) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckUsername) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckUsername) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintChat(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PeerType != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x10
	}
	if m.PeerId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BannedUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BannedUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BannedUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x50
	}
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x48
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x40
	}
	if m.UtilDate != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UtilDate))
		i--
		dAtA[i] = 0x38
	}
	if m.Rights != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Rights))
		i--
		dAtA[i] = 0x30
	}
	if m.IsLeft {
		i--
		if m.IsLeft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IsDeleted {
		i--
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.IsBanned {
		i--
		if m.IsBanned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.PeerId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EditGeoPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditGeoPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EditGeoPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.GeoPoint != nil {
		{
			size, err := m.GeoPoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.PeerId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InviteToChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InviteToChannel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InviteToChannel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PeerIdList) > 0 {
		dAtA18 := make([]byte, len(m.PeerIdList)*10)
		var j17 int
		for _, num1 := range m.PeerIdList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintChat(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x22
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteChat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteChat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HistoryHidden) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistoryHidden) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HistoryHidden) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateUsername) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUsername) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateUsername) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintChat(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x22
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteMessagesUpdates) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMessagesUpdates) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteMessagesUpdates) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pts != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Pts))
		i--
		dAtA[i] = 0x28
	}
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Ids) > 0 {
		dAtA20 := make([]byte, len(m.Ids)*10)
		var j19 int
		for _, num1 := range m.Ids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintChat(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x1a
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.PeerId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.MaxId))
		i--
		dAtA[i] = 0x28
	}
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteMessages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMessages) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteMessages) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ids) > 0 {
		dAtA22 := make([]byte, len(m.Ids)*10)
		var j21 int
		for _, num1 := range m.Ids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintChat(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x2a
	}
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteUserHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteUserHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PeerId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x28
	}
	if m.Date != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetParticipants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetParticipants) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetParticipants) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Q) > 0 {
		i -= len(m.Q)
		copy(dAtA[i:], m.Q)
		i = encodeVarintChat(dAtA, i, uint64(len(m.Q)))
		i--
		dAtA[i] = 0x32
	}
	if m.Limit != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.Offset != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if m.Filter != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.Filter))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintChat(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintChat(dAtA []byte, offset int, v uint64) int {
	offset -= sovChat(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Chat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatData != nil {
		l = m.ChatData.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if len(m.ParticipantList) > 0 {
		for _, e := range m.ParticipantList {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	return n
}

func (m *ChatList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	return n
}

func (m *GeoPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lat != 0 {
		n += 9
	}
	if m.Long != 0 {
		n += 9
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *CreateChat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if len(m.PeerId) > 0 {
		l = 0
		for _, e := range m.PeerId {
			l += sovChat(uint64(e))
		}
		n += 1 + sovChat(uint64(l)) + l
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	if m.ChatSizeMax != 0 {
		n += 1 + sovChat(uint64(m.ChatSizeMax))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	if m.GeoPoint != nil {
		l = m.GeoPoint.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovChat(uint64(m.Layer))
	}
	return n
}

func (m *FullChat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	return n
}

func (m *ChatCommon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.MaxId != 0 {
		n += 1 + sovChat(uint64(m.MaxId))
	}
	if m.Limit != 0 {
		n += 1 + sovChat(uint64(m.Limit))
	}
	return n
}

func (m *EditTitle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	return n
}

func (m *EditAbout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	l = len(m.About)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	return n
}

func (m *EditPhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	return n
}

func (m *BannedRights) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.Rights != 0 {
		n += 1 + sovChat(uint64(m.Rights))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	if m.UtilDate != 0 {
		n += 1 + sovChat(uint64(m.UtilDate))
	}
	return n
}

func (m *EditAdmin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.PeerId != 0 {
		n += 1 + sovChat(uint64(m.PeerId))
	}
	if m.IsAdmin {
		n += 2
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	if m.Right != 0 {
		n += 1 + sovChat(uint64(m.Right))
	}
	return n
}

func (m *ChatByName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	return n
}

func (m *AddUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.PeerId != 0 {
		n += 1 + sovChat(uint64(m.PeerId))
	}
	if m.FwdLimit != 0 {
		n += 1 + sovChat(uint64(m.FwdLimit))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	return n
}

func (m *DeleteUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.PeerId != 0 {
		n += 1 + sovChat(uint64(m.PeerId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	return n
}

func (m *SendOutboxesMessages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *SendInBoxesMessages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *SendMessagesList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovChat(uint64(l))
		}
	}
	return n
}

func (m *ChatReadHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *ReadInMessages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *AllChat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExceptIds) > 0 {
		l = 0
		for _, e := range m.ExceptIds {
			l += sovChat(uint64(e))
		}
		n += 1 + sovChat(uint64(l)) + l
	}
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sovChat(uint64(e))
		}
		n += 1 + sovChat(uint64(l)) + l
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	return n
}

func (m *ChatPinnedMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PinnedMessage != nil {
		l = m.PinnedMessage.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *ChatInPinnedMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PinnedMessage != nil {
		l = m.PinnedMessage.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *CheckUsername) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PeerId != 0 {
		n += 1 + sovChat(uint64(m.PeerId))
	}
	if m.PeerType != 0 {
		n += 1 + sovChat(uint64(m.PeerType))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *BannedUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PeerId != 0 {
		n += 1 + sovChat(uint64(m.PeerId))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.IsBanned {
		n += 2
	}
	if m.IsDeleted {
		n += 2
	}
	if m.IsLeft {
		n += 2
	}
	if m.Rights != 0 {
		n += 1 + sovChat(uint64(m.Rights))
	}
	if m.UtilDate != 0 {
		n += 1 + sovChat(uint64(m.UtilDate))
	}
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	return n
}

func (m *EditGeoPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PeerId != 0 {
		n += 1 + sovChat(uint64(m.PeerId))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.GeoPoint != nil {
		l = m.GeoPoint.Size()
		n += 1 + l + sovChat(uint64(l))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	return n
}

func (m *InviteToChannel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if len(m.PeerIdList) > 0 {
		l = 0
		for _, e := range m.PeerIdList {
			l += sovChat(uint64(e))
		}
		n += 1 + sovChat(uint64(l)) + l
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	return n
}

func (m *DeleteChat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	return n
}

func (m *HistoryHidden) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *UpdateUsername) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func (m *DeleteMessagesUpdates) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PeerId != 0 {
		n += 1 + sovChat(uint64(m.PeerId))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sovChat(uint64(e))
		}
		n += 1 + sovChat(uint64(l)) + l
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	if m.Pts != 0 {
		n += 1 + sovChat(uint64(m.Pts))
	}
	return n
}

func (m *DeleteHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	if m.MaxId != 0 {
		n += 1 + sovChat(uint64(m.MaxId))
	}
	return n
}

func (m *DeleteMessages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sovChat(uint64(e))
		}
		n += 1 + sovChat(uint64(l)) + l
	}
	return n
}

func (m *DeleteUserHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovChat(uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovChat(uint64(m.Date))
	}
	if m.PeerId != 0 {
		n += 1 + sovChat(uint64(m.PeerId))
	}
	return n
}

func (m *GetParticipants) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovChat(uint64(m.ChatId))
	}
	if m.UserId != 0 {
		n += 1 + sovChat(uint64(m.UserId))
	}
	if m.Filter != 0 {
		n += 1 + sovChat(uint64(m.Filter))
	}
	if m.Offset != 0 {
		n += 1 + sovChat(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovChat(uint64(m.Limit))
	}
	l = len(m.Q)
	if l > 0 {
		n += 1 + l + sovChat(uint64(l))
	}
	return n
}

func sovChat(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChat(x uint64) (n int) {
	return sovChat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Chat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChatData == nil {
				m.ChatData = &chat.Chat{}
			}
			if err := m.ChatData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParticipantList = append(m.ParticipantList, &chat.ChatParticipant{})
			if err := m.ParticipantList[len(m.ParticipantList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &Chat{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeoPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeoPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeoPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lat = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Long", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Long = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PeerId = append(m.PeerId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChat
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChat
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PeerId) == 0 {
					m.PeerId = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PeerId = append(m.PeerId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatSizeMax", wireType)
			}
			m.ChatSizeMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatSizeMax |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoPoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeoPoint == nil {
				m.GeoPoint = &GeoPoint{}
			}
			if err := m.GeoPoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FullChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FullChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FullChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatCommon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatCommon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatCommon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditTitle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EditTitle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EditTitle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditAbout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EditAbout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EditAbout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.About = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EditPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EditPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &fs.PhotoProfile{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BannedRights) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BannedRights: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BannedRights: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rights", wireType)
			}
			m.Rights = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rights |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtilDate", wireType)
			}
			m.UtilDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UtilDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditAdmin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EditAdmin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EditAdmin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAdmin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAdmin = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			m.Right = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Right |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatByName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatByName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatByName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdLimit", wireType)
			}
			m.FwdLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendOutboxesMessages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendOutboxesMessages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendOutboxesMessages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &rpc_client.SendMessages{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendInBoxesMessages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendInBoxesMessages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendInBoxesMessages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &rpc_client.SendMessages{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMessagesList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendMessagesList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendMessagesList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &rpc_client.SendMessages{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatReadHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatReadHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatReadHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &rpc_client.ReadHistory{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadInMessages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadInMessages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadInMessages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &rpc_client.ReadHistory{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExceptIds = append(m.ExceptIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChat
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChat
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ExceptIds) == 0 {
					m.ExceptIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExceptIds = append(m.ExceptIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExceptIds", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ids = append(m.Ids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChat
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChat
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ids) == 0 {
					m.Ids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ids = append(m.Ids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatPinnedMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatPinnedMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatPinnedMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PinnedMessage == nil {
				m.PinnedMessage = &rpc_client.PinnedMessage{}
			}
			if err := m.PinnedMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatInPinnedMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatInPinnedMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatInPinnedMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PinnedMessage == nil {
				m.PinnedMessage = &rpc_client.PinnedMessage{}
			}
			if err := m.PinnedMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckUsername) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckUsername: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckUsername: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BannedUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BannedUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BannedUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBanned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBanned = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeft = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rights", wireType)
			}
			m.Rights = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rights |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtilDate", wireType)
			}
			m.UtilDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UtilDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditGeoPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EditGeoPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EditGeoPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoPoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeoPoint == nil {
				m.GeoPoint = &GeoPoint{}
			}
			if err := m.GeoPoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InviteToChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InviteToChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InviteToChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PeerIdList = append(m.PeerIdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChat
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChat
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PeerIdList) == 0 {
					m.PeerIdList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PeerIdList = append(m.PeerIdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerIdList", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistoryHidden) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistoryHidden: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistoryHidden: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUsername) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUsername: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUsername: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMessagesUpdates) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMessagesUpdates: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMessagesUpdates: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ids = append(m.Ids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChat
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChat
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ids) == 0 {
					m.Ids = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ids = append(m.Ids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMessages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMessages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMessages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ids = append(m.Ids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthChat
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthChat
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ids) == 0 {
					m.Ids = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ids = append(m.Ids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetParticipants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetParticipants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetParticipants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			m.Filter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Filter |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Q = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChat
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChat
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChat
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChat        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChat          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChat = fmt.Errorf("proto: unexpected end of group")
)

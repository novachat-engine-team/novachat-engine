// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: attributes.proto

package data_fs

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type StickerSet struct {
	StickerSetType int32  `protobuf:"varint,1,opt,name=sticker_set_type,json=stickerSetType,proto3" json:"sticker_set_type,omitempty" bson:"sticker_set_type"`
	StickerSetId   int64  `protobuf:"varint,2,opt,name=sticker_set_id,json=stickerSetId,proto3" json:"sticker_set_id,omitempty" bson:"sticker_set_id"`
	AccessHash     int64  `protobuf:"varint,3,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty" bson:"access_hash"`
	ShortName      string `protobuf:"bytes,4,opt,name=short_name,json=shortName,proto3" json:"short_name,omitempty" bson:"short_name"`
	Emoticon       string `protobuf:"bytes,5,opt,name=emoticon,proto3" json:"emoticon,omitempty" bson:"emoticon"`
}

func (m *StickerSet) Reset()         { *m = StickerSet{} }
func (m *StickerSet) String() string { return proto.CompactTextString(m) }
func (*StickerSet) ProtoMessage()    {}
func (*StickerSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f97a9220cd723d2e, []int{0}
}
func (m *StickerSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StickerSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StickerSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StickerSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StickerSet.Merge(m, src)
}
func (m *StickerSet) XXX_Size() int {
	return m.Size()
}
func (m *StickerSet) XXX_DiscardUnknown() {
	xxx_messageInfo_StickerSet.DiscardUnknown(m)
}

var xxx_messageInfo_StickerSet proto.InternalMessageInfo

func (m *StickerSet) GetStickerSetType() int32 {
	if m != nil {
		return m.StickerSetType
	}
	return 0
}

func (m *StickerSet) GetStickerSetId() int64 {
	if m != nil {
		return m.StickerSetId
	}
	return 0
}

func (m *StickerSet) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *StickerSet) GetShortName() string {
	if m != nil {
		return m.ShortName
	}
	return ""
}

func (m *StickerSet) GetEmoticon() string {
	if m != nil {
		return m.Emoticon
	}
	return ""
}

//maskCoords#aed6dbb2 n:int x:double y:double zoom:double = MaskCoords;
type MaskCoords struct {
	N    int32   `protobuf:"varint,1,opt,name=n,proto3" json:"n,omitempty" bson:"n"`
	X    float64 `protobuf:"fixed64,2,opt,name=x,proto3" json:"x,omitempty" bson:"x"`
	Y    float64 `protobuf:"fixed64,3,opt,name=y,proto3" json:"y,omitempty" bson:"y"`
	Zoom float64 `protobuf:"fixed64,4,opt,name=zoom,proto3" json:"zoom,omitempty" bson:"zoom"`
}

func (m *MaskCoords) Reset()         { *m = MaskCoords{} }
func (m *MaskCoords) String() string { return proto.CompactTextString(m) }
func (*MaskCoords) ProtoMessage()    {}
func (*MaskCoords) Descriptor() ([]byte, []int) {
	return fileDescriptor_f97a9220cd723d2e, []int{1}
}
func (m *MaskCoords) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaskCoords) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaskCoords.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaskCoords) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaskCoords.Merge(m, src)
}
func (m *MaskCoords) XXX_Size() int {
	return m.Size()
}
func (m *MaskCoords) XXX_DiscardUnknown() {
	xxx_messageInfo_MaskCoords.DiscardUnknown(m)
}

var xxx_messageInfo_MaskCoords proto.InternalMessageInfo

func (m *MaskCoords) GetN() int32 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *MaskCoords) GetX() float64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *MaskCoords) GetY() float64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *MaskCoords) GetZoom() float64 {
	if m != nil {
		return m.Zoom
	}
	return 0
}

type Attributes struct {
	AttributesType int32 `protobuf:"varint,1,opt,name=attributes_type,json=attributesType,proto3" json:"attributes_type,omitempty" bson:"attributes_type"`
	// documentAttributeFilename
	Filename string `protobuf:"bytes,2,opt,name=filename,proto3" json:"filename,omitempty" bson:"filename"`
	// documentAttributeImageSize
	ImageW int32 `protobuf:"varint,3,opt,name=image_w,json=imageW,proto3" json:"image_w,omitempty" bson:"image_w"`
	ImageH int32 `protobuf:"varint,4,opt,name=image_h,json=imageH,proto3" json:"image_h,omitempty" bson:"image_h"`
	// documentAttributeAnimated
	//bool animated = 5 [(gogoproto.moretags) = "bson:\"animated\""];
	// documentAttributeSticker
	StickerData *StickerSet `protobuf:"bytes,7,opt,name=sticker_data,json=stickerData,proto3" json:"sticker_data,omitempty" bson:"sticker_data"`
	Mask        bool        `protobuf:"varint,8,opt,name=mask,proto3" json:"mask,omitempty" bson:"mask"`
	Alt         string      `protobuf:"bytes,9,opt,name=alt,proto3" json:"alt,omitempty" bson:"alt"`
	MaskCoords  *MaskCoords `protobuf:"bytes,10,opt,name=mask_coords,json=maskCoords,proto3" json:"mask_coords,omitempty" bson:"mask_coords"`
	// documentAttributeVideo
	RoundMessage      bool  `protobuf:"varint,11,opt,name=round_message,json=roundMessage,proto3" json:"round_message,omitempty" bson:"round_message"`
	SupportsStreaming bool  `protobuf:"varint,12,opt,name=supports_streaming,json=supportsStreaming,proto3" json:"supports_streaming,omitempty" bson:"supports_streaming"`
	VideoDuration     int32 `protobuf:"varint,13,opt,name=video_duration,json=videoDuration,proto3" json:"video_duration,omitempty" bson:"video_duration"`
	VideoW            int32 `protobuf:"varint,14,opt,name=video_w,json=videoW,proto3" json:"video_w,omitempty" bson:"video_w"`
	VideoH            int32 `protobuf:"varint,15,opt,name=video_h,json=videoH,proto3" json:"video_h,omitempty" bson:"video_h"`
	//documentAttributeAudio
	Voice         bool   `protobuf:"varint,16,opt,name=voice,proto3" json:"voice,omitempty" bson:"voice"`
	AudioDuration int32  `protobuf:"varint,17,opt,name=audio_duration,json=audioDuration,proto3" json:"audio_duration,omitempty" bson:"audio_duration"`
	Title         string `protobuf:"bytes,18,opt,name=title,proto3" json:"title,omitempty" bson:"title"`
	Performer     string `protobuf:"bytes,19,opt,name=performer,proto3" json:"performer,omitempty" bson:"performer"`
	Waveform      []byte `protobuf:"bytes,20,opt,name=waveform,proto3" json:"waveform,omitempty" bson:"waveform"`
	// documentAttributeHasStickers
	Stickers bool `protobuf:"varint,21,opt,name=stickers,proto3" json:"stickers,omitempty" bson:"stickers"`
}

func (m *Attributes) Reset()         { *m = Attributes{} }
func (m *Attributes) String() string { return proto.CompactTextString(m) }
func (*Attributes) ProtoMessage()    {}
func (*Attributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_f97a9220cd723d2e, []int{2}
}
func (m *Attributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Attributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Attributes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Attributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attributes.Merge(m, src)
}
func (m *Attributes) XXX_Size() int {
	return m.Size()
}
func (m *Attributes) XXX_DiscardUnknown() {
	xxx_messageInfo_Attributes.DiscardUnknown(m)
}

var xxx_messageInfo_Attributes proto.InternalMessageInfo

func (m *Attributes) GetAttributesType() int32 {
	if m != nil {
		return m.AttributesType
	}
	return 0
}

func (m *Attributes) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *Attributes) GetImageW() int32 {
	if m != nil {
		return m.ImageW
	}
	return 0
}

func (m *Attributes) GetImageH() int32 {
	if m != nil {
		return m.ImageH
	}
	return 0
}

func (m *Attributes) GetStickerData() *StickerSet {
	if m != nil {
		return m.StickerData
	}
	return nil
}

func (m *Attributes) GetMask() bool {
	if m != nil {
		return m.Mask
	}
	return false
}

func (m *Attributes) GetAlt() string {
	if m != nil {
		return m.Alt
	}
	return ""
}

func (m *Attributes) GetMaskCoords() *MaskCoords {
	if m != nil {
		return m.MaskCoords
	}
	return nil
}

func (m *Attributes) GetRoundMessage() bool {
	if m != nil {
		return m.RoundMessage
	}
	return false
}

func (m *Attributes) GetSupportsStreaming() bool {
	if m != nil {
		return m.SupportsStreaming
	}
	return false
}

func (m *Attributes) GetVideoDuration() int32 {
	if m != nil {
		return m.VideoDuration
	}
	return 0
}

func (m *Attributes) GetVideoW() int32 {
	if m != nil {
		return m.VideoW
	}
	return 0
}

func (m *Attributes) GetVideoH() int32 {
	if m != nil {
		return m.VideoH
	}
	return 0
}

func (m *Attributes) GetVoice() bool {
	if m != nil {
		return m.Voice
	}
	return false
}

func (m *Attributes) GetAudioDuration() int32 {
	if m != nil {
		return m.AudioDuration
	}
	return 0
}

func (m *Attributes) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Attributes) GetPerformer() string {
	if m != nil {
		return m.Performer
	}
	return ""
}

func (m *Attributes) GetWaveform() []byte {
	if m != nil {
		return m.Waveform
	}
	return nil
}

func (m *Attributes) GetStickers() bool {
	if m != nil {
		return m.Stickers
	}
	return false
}

func init() {
	proto.RegisterType((*StickerSet)(nil), "data_fs.StickerSet")
	proto.RegisterType((*MaskCoords)(nil), "data_fs.MaskCoords")
	proto.RegisterType((*Attributes)(nil), "data_fs.Attributes")
}

func init() { proto.RegisterFile("attributes.proto", fileDescriptor_f97a9220cd723d2e) }

var fileDescriptor_f97a9220cd723d2e = []byte{
	// 815 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x95, 0xdf, 0x6a, 0x23, 0x37,
	0x14, 0xc6, 0xa3, 0x64, 0x9d, 0x38, 0xb2, 0xe3, 0x38, 0x4a, 0xb2, 0xab, 0xa4, 0xd4, 0x32, 0x2a,
	0x2c, 0x86, 0x52, 0x1b, 0xb6, 0x85, 0xc2, 0x42, 0x69, 0xeb, 0xdd, 0x42, 0x0a, 0xbb, 0x2d, 0x28,
	0x85, 0x85, 0xde, 0x0c, 0xb2, 0x47, 0xf6, 0x0c, 0xf1, 0x8c, 0xcc, 0x48, 0x4e, 0xe2, 0x3e, 0x45,
	0xa1, 0x37, 0xbd, 0xdd, 0x7d, 0x94, 0x5e, 0xf5, 0x72, 0x9f, 0x60, 0x68, 0xf3, 0x04, 0x65, 0x9e,
	0xa0, 0xcc, 0x99, 0xbf, 0xf6, 0xee, 0x9d, 0xce, 0xf9, 0x7d, 0x47, 0xd6, 0x39, 0xfa, 0xe4, 0xc1,
	0x5d, 0x69, 0x6d, 0xe4, 0x4f, 0x56, 0x56, 0x99, 0xe1, 0x32, 0xd2, 0x56, 0x93, 0x03, 0x57, 0x5a,
	0xe9, 0xcc, 0xcc, 0xe5, 0x17, 0x73, 0xdf, 0x7a, 0xab, 0xc9, 0x70, 0xaa, 0x83, 0xd1, 0x5c, 0xcf,
	0xf5, 0x08, 0xf8, 0x64, 0x35, 0x83, 0x08, 0x02, 0x58, 0x65, 0x75, 0xfc, 0xaf, 0x5d, 0x8c, 0xaf,
	0xad, 0x3f, 0xbd, 0x51, 0xd1, 0xb5, 0xb2, 0xe4, 0x07, 0xdc, 0x35, 0x59, 0xe4, 0x18, 0x65, 0x1d,
	0xbb, 0x5e, 0x2a, 0x8a, 0xfa, 0x68, 0xd0, 0x18, 0x7f, 0x92, 0xc4, 0xec, 0xc9, 0xc4, 0xe8, 0xf0,
	0x39, 0xdf, 0x56, 0x70, 0xd1, 0x31, 0xe5, 0x16, 0xbf, 0xac, 0x97, 0x8a, 0x7c, 0x8b, 0x3b, 0x75,
	0x91, 0xef, 0xd2, 0xdd, 0x3e, 0x1a, 0xec, 0x8d, 0x2f, 0x92, 0x98, 0x9d, 0x7f, 0xb8, 0x89, 0xef,
	0x72, 0xd1, 0xae, 0xb6, 0xf8, 0xd1, 0x25, 0x5f, 0xe3, 0x96, 0x9c, 0x4e, 0x95, 0x31, 0x8e, 0x27,
	0x8d, 0x47, 0xf7, 0xa0, 0xfa, 0x71, 0x12, 0x33, 0x92, 0x55, 0xd7, 0x20, 0x17, 0x38, 0x8b, 0xae,
	0xa4, 0xf1, 0xc8, 0x57, 0x18, 0x1b, 0x4f, 0x47, 0xd6, 0x09, 0x65, 0xa0, 0xe8, 0xa3, 0x3e, 0x1a,
	0x1c, 0x8e, 0xcf, 0x93, 0x98, 0x9d, 0xe4, 0xbf, 0x5a, 0x32, 0x2e, 0x0e, 0x21, 0xf8, 0x49, 0x06,
	0x8a, 0x8c, 0x70, 0x53, 0x05, 0xda, 0xfa, 0x53, 0x1d, 0xd2, 0x06, 0xd4, 0x9c, 0x26, 0x31, 0x3b,
	0xce, 0x6a, 0x0a, 0xc2, 0x45, 0x29, 0x7a, 0xde, 0x7e, 0xff, 0x96, 0xed, 0xfc, 0xfe, 0x8e, 0xed,
	0xfc, 0xf9, 0x8e, 0xed, 0xf0, 0x3f, 0x10, 0xc6, 0xaf, 0xa5, 0xb9, 0x79, 0xa1, 0x75, 0xe4, 0x1a,
	0x72, 0x89, 0x51, 0x98, 0x4f, 0xad, 0x9d, 0xc4, 0xac, 0x99, 0x6d, 0x13, 0x72, 0x81, 0xc2, 0x94,
	0xdd, 0xc3, 0x30, 0x50, 0x9d, 0xdd, 0x73, 0x81, 0xee, 0x53, 0xb6, 0x86, 0x56, 0x37, 0xd8, 0x9a,
	0x0b, 0xb4, 0x26, 0x9f, 0xe1, 0x47, 0xbf, 0x69, 0x1d, 0x40, 0x47, 0x68, 0x7c, 0x9c, 0xc4, 0xac,
	0x95, 0xe1, 0x34, 0xcb, 0x05, 0xc0, 0xad, 0x53, 0xbd, 0x6d, 0x62, 0xfc, 0x7d, 0xe9, 0x13, 0xf2,
	0x02, 0x1f, 0x57, 0xae, 0xa9, 0xdf, 0xec, 0x65, 0x12, 0xb3, 0xc7, 0xf9, 0x58, 0x37, 0x05, 0x5c,
	0x74, 0xaa, 0x0c, 0x5c, 0xec, 0x08, 0x37, 0x67, 0xfe, 0x42, 0xc1, 0x70, 0x77, 0xb7, 0x07, 0x55,
	0x10, 0x2e, 0x4a, 0x11, 0xf9, 0x1c, 0x1f, 0xf8, 0x81, 0x9c, 0x2b, 0xe7, 0x0e, 0x3a, 0x6b, 0x8c,
	0x49, 0x12, 0xb3, 0x4e, 0xa6, 0xcf, 0x01, 0x17, 0xfb, 0xb0, 0x7a, 0x53, 0x89, 0x3d, 0xe8, 0xf3,
	0x23, 0x62, 0xaf, 0x10, 0x5f, 0x91, 0x9f, 0x71, 0x61, 0x19, 0x27, 0xf5, 0x3e, 0x3d, 0xe8, 0xa3,
	0x41, 0xeb, 0xd9, 0xe9, 0x30, 0x7f, 0x08, 0xc3, 0xca, 0xd5, 0xe3, 0x27, 0x49, 0xcc, 0x4e, 0x37,
	0x6d, 0x97, 0xaa, 0xb8, 0x68, 0xe5, 0xe1, 0x4b, 0x69, 0x65, 0x3a, 0xe2, 0x40, 0x9a, 0x1b, 0xda,
	0xec, 0xa3, 0x41, 0xb3, 0x3e, 0xe2, 0x34, 0xcb, 0x05, 0x40, 0xd2, 0xc7, 0x7b, 0x72, 0x61, 0xe9,
	0x21, 0xf4, 0xde, 0x49, 0x62, 0x86, 0xf3, 0xc9, 0x2d, 0x2c, 0x17, 0x29, 0x22, 0xaf, 0x70, 0x2b,
	0x55, 0x3a, 0x53, 0x30, 0x03, 0xc5, 0x5b, 0xc7, 0xaa, 0x7c, 0x52, 0xf7, 0x73, 0xad, 0x82, 0x0b,
	0x1c, 0x54, 0x5e, 0xfa, 0x06, 0x1f, 0x45, 0x7a, 0x15, 0xba, 0x4e, 0xa0, 0x8c, 0x91, 0x73, 0x45,
	0x5b, 0x70, 0x3a, 0x9a, 0xc4, 0xec, 0x2c, 0x2b, 0xdd, 0xc0, 0x5c, 0xb4, 0x21, 0x7e, 0x9d, 0x85,
	0xe4, 0x15, 0x26, 0x66, 0xb5, 0x5c, 0xea, 0xc8, 0x1a, 0xc7, 0xd8, 0x48, 0xc9, 0xc0, 0x0f, 0xe7,
	0xb4, 0x0d, 0x7b, 0x7c, 0x9a, 0xc4, 0xec, 0x22, 0x9f, 0xca, 0x07, 0x1a, 0x2e, 0x4e, 0x8a, 0xe4,
	0x75, 0x91, 0x23, 0xdf, 0xe1, 0xce, 0xad, 0xef, 0x2a, 0xed, 0xb8, 0xab, 0x48, 0x5a, 0x5f, 0x87,
	0xf4, 0x08, 0xae, 0xa9, 0xf6, 0xac, 0x37, 0x39, 0x17, 0x47, 0x90, 0x78, 0x99, 0xc7, 0xe9, 0x0d,
	0x67, 0x8a, 0x3b, 0xda, 0xd9, 0xbe, 0xe1, 0x1c, 0x70, 0xb1, 0x0f, 0xab, 0x37, 0x95, 0xd8, 0xa3,
	0xc7, 0x1f, 0x17, 0x7b, 0x85, 0xf8, 0x8a, 0x3c, 0xc5, 0x8d, 0x5b, 0xed, 0x4f, 0x15, 0xed, 0x42,
	0x73, 0xdd, 0x24, 0x66, 0xed, 0x5c, 0x9a, 0xa6, 0xb9, 0xc8, 0x70, 0xda, 0x83, 0x5c, 0xb9, 0x7e,
	0xad, 0x87, 0x93, 0xed, 0x1e, 0x36, 0x39, 0x17, 0x47, 0x90, 0x28, 0x7b, 0x78, 0x8a, 0x1b, 0xd6,
	0xb7, 0x0b, 0x45, 0x09, 0x98, 0xa0, 0xf6, 0x4b, 0x90, 0xe6, 0x22, 0xc3, 0xe4, 0x19, 0x3e, 0x5c,
	0xaa, 0x68, 0xa6, 0xa3, 0x40, 0x45, 0xf4, 0x14, 0xb4, 0x67, 0x49, 0xcc, 0xba, 0x99, 0xb6, 0x44,
	0x5c, 0x54, 0xb2, 0xf4, 0x7d, 0xdd, 0xc9, 0x5b, 0x95, 0x46, 0xf4, 0xac, 0x8f, 0x06, 0xed, 0xfa,
	0xfb, 0x2a, 0x08, 0x17, 0xa5, 0x28, 0x2d, 0xc8, 0x3d, 0x6c, 0xe8, 0x39, 0x74, 0x5e, 0x2b, 0x28,
	0x08, 0x17, 0xa5, 0x68, 0xf3, 0x3f, 0x62, 0x7c, 0xf1, 0xdf, 0xbf, 0x3d, 0xf4, 0xf7, 0x43, 0x0f,
	0xbd, 0x7f, 0xe8, 0xa1, 0x7f, 0x1e, 0x7a, 0xe8, 0xd7, 0xe2, 0x43, 0x32, 0xd9, 0x87, 0x0f, 0xc4,
	0x97, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0x5b, 0xcc, 0x6b, 0xd7, 0x6c, 0x06, 0x00, 0x00,
}

func (this *StickerSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&data_fs.StickerSet{")
	s = append(s, "StickerSetType: "+fmt.Sprintf("%#v", this.StickerSetType)+",\n")
	s = append(s, "StickerSetId: "+fmt.Sprintf("%#v", this.StickerSetId)+",\n")
	s = append(s, "AccessHash: "+fmt.Sprintf("%#v", this.AccessHash)+",\n")
	s = append(s, "ShortName: "+fmt.Sprintf("%#v", this.ShortName)+",\n")
	s = append(s, "Emoticon: "+fmt.Sprintf("%#v", this.Emoticon)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MaskCoords) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&data_fs.MaskCoords{")
	s = append(s, "N: "+fmt.Sprintf("%#v", this.N)+",\n")
	s = append(s, "X: "+fmt.Sprintf("%#v", this.X)+",\n")
	s = append(s, "Y: "+fmt.Sprintf("%#v", this.Y)+",\n")
	s = append(s, "Zoom: "+fmt.Sprintf("%#v", this.Zoom)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Attributes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 23)
	s = append(s, "&data_fs.Attributes{")
	s = append(s, "AttributesType: "+fmt.Sprintf("%#v", this.AttributesType)+",\n")
	s = append(s, "Filename: "+fmt.Sprintf("%#v", this.Filename)+",\n")
	s = append(s, "ImageW: "+fmt.Sprintf("%#v", this.ImageW)+",\n")
	s = append(s, "ImageH: "+fmt.Sprintf("%#v", this.ImageH)+",\n")
	if this.StickerData != nil {
		s = append(s, "StickerData: "+fmt.Sprintf("%#v", this.StickerData)+",\n")
	}
	s = append(s, "Mask: "+fmt.Sprintf("%#v", this.Mask)+",\n")
	s = append(s, "Alt: "+fmt.Sprintf("%#v", this.Alt)+",\n")
	if this.MaskCoords != nil {
		s = append(s, "MaskCoords: "+fmt.Sprintf("%#v", this.MaskCoords)+",\n")
	}
	s = append(s, "RoundMessage: "+fmt.Sprintf("%#v", this.RoundMessage)+",\n")
	s = append(s, "SupportsStreaming: "+fmt.Sprintf("%#v", this.SupportsStreaming)+",\n")
	s = append(s, "VideoDuration: "+fmt.Sprintf("%#v", this.VideoDuration)+",\n")
	s = append(s, "VideoW: "+fmt.Sprintf("%#v", this.VideoW)+",\n")
	s = append(s, "VideoH: "+fmt.Sprintf("%#v", this.VideoH)+",\n")
	s = append(s, "Voice: "+fmt.Sprintf("%#v", this.Voice)+",\n")
	s = append(s, "AudioDuration: "+fmt.Sprintf("%#v", this.AudioDuration)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "Performer: "+fmt.Sprintf("%#v", this.Performer)+",\n")
	s = append(s, "Waveform: "+fmt.Sprintf("%#v", this.Waveform)+",\n")
	s = append(s, "Stickers: "+fmt.Sprintf("%#v", this.Stickers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAttributes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *StickerSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StickerSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StickerSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Emoticon) > 0 {
		i -= len(m.Emoticon)
		copy(dAtA[i:], m.Emoticon)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Emoticon)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ShortName) > 0 {
		i -= len(m.ShortName)
		copy(dAtA[i:], m.ShortName)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.ShortName)))
		i--
		dAtA[i] = 0x22
	}
	if m.AccessHash != 0 {
		i = encodeVarintAttributes(dAtA, i, uint64(m.AccessHash))
		i--
		dAtA[i] = 0x18
	}
	if m.StickerSetId != 0 {
		i = encodeVarintAttributes(dAtA, i, uint64(m.StickerSetId))
		i--
		dAtA[i] = 0x10
	}
	if m.StickerSetType != 0 {
		i = encodeVarintAttributes(dAtA, i, uint64(m.StickerSetType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MaskCoords) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaskCoords) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaskCoords) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Zoom != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Zoom))))
		i--
		dAtA[i] = 0x21
	}
	if m.Y != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Y))))
		i--
		dAtA[i] = 0x19
	}
	if m.X != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X))))
		i--
		dAtA[i] = 0x11
	}
	if m.N != 0 {
		i = encodeVarintAttributes(dAtA, i, uint64(m.N))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Attributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Attributes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Attributes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Stickers {
		i--
		if m.Stickers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.Waveform) > 0 {
		i -= len(m.Waveform)
		copy(dAtA[i:], m.Waveform)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Waveform)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Performer) > 0 {
		i -= len(m.Performer)
		copy(dAtA[i:], m.Performer)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Performer)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.AudioDuration != 0 {
		i = encodeVarintAttributes(dAtA, i, uint64(m.AudioDuration))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Voice {
		i--
		if m.Voice {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.VideoH != 0 {
		i = encodeVarintAttributes(dAtA, i, uint64(m.VideoH))
		i--
		dAtA[i] = 0x78
	}
	if m.VideoW != 0 {
		i = encodeVarintAttributes(dAtA, i, uint64(m.VideoW))
		i--
		dAtA[i] = 0x70
	}
	if m.VideoDuration != 0 {
		i = encodeVarintAttributes(dAtA, i, uint64(m.VideoDuration))
		i--
		dAtA[i] = 0x68
	}
	if m.SupportsStreaming {
		i--
		if m.SupportsStreaming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.RoundMessage {
		i--
		if m.RoundMessage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.MaskCoords != nil {
		{
			size, err := m.MaskCoords.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAttributes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Alt) > 0 {
		i -= len(m.Alt)
		copy(dAtA[i:], m.Alt)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Alt)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Mask {
		i--
		if m.Mask {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.StickerData != nil {
		{
			size, err := m.StickerData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAttributes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.ImageH != 0 {
		i = encodeVarintAttributes(dAtA, i, uint64(m.ImageH))
		i--
		dAtA[i] = 0x20
	}
	if m.ImageW != 0 {
		i = encodeVarintAttributes(dAtA, i, uint64(m.ImageW))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x12
	}
	if m.AttributesType != 0 {
		i = encodeVarintAttributes(dAtA, i, uint64(m.AttributesType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAttributes(dAtA []byte, offset int, v uint64) int {
	offset -= sovAttributes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StickerSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StickerSetType != 0 {
		n += 1 + sovAttributes(uint64(m.StickerSetType))
	}
	if m.StickerSetId != 0 {
		n += 1 + sovAttributes(uint64(m.StickerSetId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovAttributes(uint64(m.AccessHash))
	}
	l = len(m.ShortName)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Emoticon)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	return n
}

func (m *MaskCoords) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.N != 0 {
		n += 1 + sovAttributes(uint64(m.N))
	}
	if m.X != 0 {
		n += 9
	}
	if m.Y != 0 {
		n += 9
	}
	if m.Zoom != 0 {
		n += 9
	}
	return n
}

func (m *Attributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttributesType != 0 {
		n += 1 + sovAttributes(uint64(m.AttributesType))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	if m.ImageW != 0 {
		n += 1 + sovAttributes(uint64(m.ImageW))
	}
	if m.ImageH != 0 {
		n += 1 + sovAttributes(uint64(m.ImageH))
	}
	if m.StickerData != nil {
		l = m.StickerData.Size()
		n += 1 + l + sovAttributes(uint64(l))
	}
	if m.Mask {
		n += 2
	}
	l = len(m.Alt)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	if m.MaskCoords != nil {
		l = m.MaskCoords.Size()
		n += 1 + l + sovAttributes(uint64(l))
	}
	if m.RoundMessage {
		n += 2
	}
	if m.SupportsStreaming {
		n += 2
	}
	if m.VideoDuration != 0 {
		n += 1 + sovAttributes(uint64(m.VideoDuration))
	}
	if m.VideoW != 0 {
		n += 1 + sovAttributes(uint64(m.VideoW))
	}
	if m.VideoH != 0 {
		n += 1 + sovAttributes(uint64(m.VideoH))
	}
	if m.Voice {
		n += 3
	}
	if m.AudioDuration != 0 {
		n += 2 + sovAttributes(uint64(m.AudioDuration))
	}
	l = len(m.Title)
	if l > 0 {
		n += 2 + l + sovAttributes(uint64(l))
	}
	l = len(m.Performer)
	if l > 0 {
		n += 2 + l + sovAttributes(uint64(l))
	}
	l = len(m.Waveform)
	if l > 0 {
		n += 2 + l + sovAttributes(uint64(l))
	}
	if m.Stickers {
		n += 3
	}
	return n
}

func sovAttributes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAttributes(x uint64) (n int) {
	return sovAttributes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StickerSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickerSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickerSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickerSetType", wireType)
			}
			m.StickerSetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StickerSetType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickerSetId", wireType)
			}
			m.StickerSetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StickerSetId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emoticon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emoticon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaskCoords) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaskCoords: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaskCoords: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Y = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zoom", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Zoom = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Attributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributesType", wireType)
			}
			m.AttributesType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributesType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageW", wireType)
			}
			m.ImageW = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageW |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageH", wireType)
			}
			m.ImageH = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImageH |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickerData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StickerData == nil {
				m.StickerData = &StickerSet{}
			}
			if err := m.StickerData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mask", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mask = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaskCoords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaskCoords == nil {
				m.MaskCoords = &MaskCoords{}
			}
			if err := m.MaskCoords.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundMessage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RoundMessage = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsStreaming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsStreaming = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoDuration", wireType)
			}
			m.VideoDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VideoDuration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoW", wireType)
			}
			m.VideoW = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VideoW |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoH", wireType)
			}
			m.VideoH = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VideoH |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voice", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Voice = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudioDuration", wireType)
			}
			m.AudioDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AudioDuration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Performer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Performer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waveform", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Waveform = append(m.Waveform[:0], dAtA[iNdEx:postIndex]...)
			if m.Waveform == nil {
				m.Waveform = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stickers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stickers = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAttributes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAttributes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAttributes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAttributes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAttributes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAttributes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAttributes = fmt.Errorf("proto: unexpected end of group")
)
